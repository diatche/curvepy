<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>curvepy.curve API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>curvepy.curve</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import math
import weakref
import inspect
import arrow
import numpy as np
from numbers import Number
from collections.abc import Sequence, Mapping
from intervalpy import Interval
from .const import GOLD
from . import util

MIN_STEP = 1e-5

# TODO: Implement Duration and use its next ad previous methods
# Or make a super class which is not tied to a time interval.

_func_obj = None

class Curve:

    _token_counter = 0

    @classmethod
    def empty(cls):
        from .empty import Empty
        return Empty()

    @property
    def min_step(self):
        return self._min_step

    @min_step.setter
    def min_step(self, value):
        self._min_step = value

    @property
    def domain(self):
        if self.needs_domain_update:
            self._domain = self.get_domain()
        return self._domain

    @property
    def update_interval(self):
        return self._begin_update_interval

    @property
    def is_updating(self):
        return not self.update_interval.is_empty

    def __init__(self, min_step=None):
        self.name = None
        self._domain = None
        self._observer_data = {}
        self._ordered_observer_tokens = []
        self._begin_update_interval = Interval.empty()
        self._end_update_interval = Interval.empty()
        self.min_step = min_step

    def __call__(self, *args):
        return self.y(args[0])

    def __repr__(self):
        try:
            if bool(self.name):
                return self.name
            return f&#39;{type(self).__name__}(&#34;{self.domain}&#34;)&#39;
        except Exception as e:
            return super().__repr__() + f&#39;({e})&#39;

    def y(self, x):
        raise Exception(&#34;Not implemented&#34;)

    def y_start(self):
        return self.y(self.domain.start)

    def y_end(self):
        return self.y(self.domain.end)

    def d_y(self, x, forward=False, min_step=MIN_STEP, limit=None):
        min_step = self.resolve_min_step(min_step)
        if forward:
            x1 = self.x_next(x, min_step=min_step, limit=limit)
        else:
            x1 = self.x_previous(x, min_step=min_step, limit=limit)

        if x1 is None:
            return None
        y1 = self.y(x1)
        if y1 is None:
            return None
        y = self.y(x)
        if y is None:
            return None
        if x1 == x:
            dy = math.inf if y1 &gt;= y else -math.inf
            if not forward:
                dy = -dy
        else:
            dy = (y1 - y) / (x1 - x)
        return dy

    def x(self, y):
        raise Exception(&#34;Not implemented&#34;)

    def x_next(self, x, min_step=MIN_STEP, limit=None):
        min_step = self.resolve_min_step(min_step)
        if math.isinf(min_step):
            x1 = self.domain.end
        else:
            x1 = x + min_step
        if limit is not None and x1 &gt; limit:
            x1 = limit
        if not self.domain.contains(x1, enforce_start=False):
            return None
        return x1

    def x_previous(self, x, min_step=MIN_STEP, limit=None):
        min_step = self.resolve_min_step(min_step)
        if math.isinf(min_step):
            x1 = self.domain.start
        else:
            x1 = x - min_step
        if limit is not None and x1 &lt; limit:
            x1 = limit
        if not self.domain.contains(x1, enforce_end=False):
            return None
        return x1

    def previous_point(self, x, min_step=MIN_STEP):
        x1 = self.x_previous(x, min_step=min_step)
        if x1 is None:
            return None
        y1 = self.y(x1)
        return (x1, y1)

    def next_point(self, x, min_step=MIN_STEP):
        x1 = self.x_next(x, min_step=min_step)
        if x1 is None:
            return None
        y1 = self.y(x1)
        return (x1, y1)

    def get_domain(self):
        return Interval.empty()

    def resolve_min_step(self, min_step):
        if min_step is None and self.min_step is None:
            return None
        elif min_step is None:
            return self.min_step
        elif self.min_step is None:
            return min_step
        else:
            return max(min_step, self.min_step)

    def sample_points(self, domain=None, min_step=MIN_STEP, step=None):
        min_step = self.resolve_min_step(min_step)
        if domain is None:
            domain = self.domain
        else:
            domain = Interval.intersection([self.domain, domain])
        if domain.is_empty:
            return []
        elif not domain.is_finite:
            raise Exception(&#34;Cannot sample points on an infinite domain {}. Specify a finite domain.&#34;.format(domain))
        x_start, x_end = domain
        x_end_bin = round(x_end / min_step) if min_step is not None else x_end
        if domain.start_open:
            points = []
        else:
            points = [(x_start, self.y(x_start))]
        if step is not None:
            x = x_start + step
            while x &lt;= x_end:
                y = self.y(x)
                points.append((x, y))
                x += step
        elif min_step is not None and min_step &gt; 0:
            x = self.x_next(x_start, min_step=min_step, limit=x_end)
            while x is not None and x &lt;= x_end:
                y = self.y(x)
                points.append((x, y))
                x_bin = round(x / min_step) if min_step is not None else x
                if x_bin == x_end_bin:
                    break
                x1 = self.x_next(x, min_step=min_step, limit=x_end)
                if x1 is not None:
                    x1_bin = round(x1 / min_step) if min_step is not None else x1
                    if x1_bin &lt;= x_bin:
                        raise Exception(&#39;Next x value {} should be greater than the previous x value {} by at least the minimum step of {}&#39;.format(x1, x, min_step))
                x = x1

            if not domain.end_open and points[-1][0] != x_end:
                points.append((x_end, self.y(x_end)))
        else:
            raise Exception(&#34;Bad functions sample parameters.&#34;)

        return points

    def sample_points_from_x(self, x, limit, backward=False, open=False, min_step=None):
        assert limit is not None
        if limit &lt; 0:
            limit = -limit
            backward = not backward
        min_step = self.resolve_min_step(min_step)
        points = []
        x1 = x
        i = 0

        if not open:
            if x is None:
                return points
            y = self.y(x)
            if y is None:
                return points
            i += 1

        while limit is None or i &lt; limit:
            if not backward:
                x1 = self.x_next(x1, min_step=min_step)
            else:
                x1 = self.x_previous(x1, min_step=min_step)
            if x1 is None:
                break
            y1 = self.y(x1)
            if y1 is None:
                break
            points.append((x1, y1))
            i += 1

        return points

    def get_range(self, domain=None, **kwargs):
        points = self.sample_points(domain=domain, **kwargs)
        low = None
        high = None
        for p in points:
            if low is None or p[1] &lt; low:
                low = p[1]
            if high is None or p[1] &gt; high:
                high = p[1]
        if low is None or high is None:
            return Interval.empty()
        return Interval(low, high)

    def minimise(self, x, min_step=MIN_STEP, step=None, max_iterations=1000):
        x_min = x
        x_min_previous = None
        iterations = 0
        while iterations &lt; max_iterations:
            iterations += 1
            y = self.y(x_min)
            if y is None:
                return x_min_previous
            dy0 = self.d_y(x_min, forward=False)
            dy1 = self.d_y(x_min, forward=True)
            forward = True
            if dy0 is None and dy1 is None:
                return x_min
            elif dy0 is None:
                if dy1 &lt;= 0:
                    forward = True
                else:
                    # Sloping into null value
                    return None
            elif dy1 is None:
                if dy0 &gt;= 0:
                    forward = False
                else:
                    # Sloping into null value
                    return None
            else:
                if dy0 * dy1 &lt; 0 and dy0 &lt;= 0 and dy1 &gt;= 0:
                    # Found minimum
                    return x_min

                if dy0 * dy1 &lt; 0:
                    # Found maximum
                    forward = abs(dy0) &lt; abs(dy1)
                else:
                    # On slope
                    forward = dy1 &lt; 0

            x_min_previous = x_min
            if forward:
                if step is not None:
                    x_min += step
                else:
                    x_min = self.x_next(x_min, min_step=min_step)
            else:
                if step is not None:
                    x_min -= step
                else:
                    x_min = self.x_previous(x_min, min_step=min_step)
        return x_min

    def maximise(self, x, min_step=MIN_STEP, step=None, max_iterations=1000):
        x_max = x
        x_max_previous = None
        iterations = 0
        while iterations &lt; max_iterations:
            iterations += 1
            y = self.y(x_max)
            if y is None:
                return x_max_previous
            dy0 = self.d_y(x_max, forward=False)
            dy1 = self.d_y(x_max, forward=True)
            forward = True
            if dy0 is None and dy1 is None:
                return x_max
            elif dy0 is None:
                if dy1 &gt;= 0:
                    forward = True
                else:
                    # Sloping into null value
                    return None
            elif dy1 is None:
                if dy0 &lt;= 0:
                    forward = False
                else:
                    # Sloping into null value
                    return None
            else:
                if dy0 * dy1 &lt; 0 and dy0 &gt;= 0 and dy1 &lt;= 0:
                    # Found maximum
                    return x_max

                if dy0 * dy1 &lt; 0:
                    # Found minimum
                    forward = abs(dy0) &lt; abs(dy1)
                else:
                    # On slope
                    forward = dy1 &gt; 0

            x_max_previous = x_max
            if forward:
                if step is not None:
                    x_max += step
                else:
                    x_max = self.x_next(x_max, min_step=min_step)
            else:
                if step is not None:
                    x_max -= step
                else:
                    x_max = self.x_previous(x_max, min_step=min_step)
        return x_max

    def regression(self, domain=None, min_step=MIN_STEP, step=None):
        points = self.sample_points(domain=domain, min_step=min_step, step=step)
        for p in points:
            if p[1] is None:
                return None
        count = len(points)
        if count &lt; 2:
            return None
            
        from .line import Line
        if count == 2:
            return Line(p1=points[0], p2=points[1])
        xy = np.vstack(points)
        x = xy[:,0]
        y = xy[:,1]
        A = np.array([x, np.ones(count)])

        # Regression
        w = np.linalg.lstsq(A.T, y, rcond=None)[0]
        m = w[0]
        c = w[1]

        return Line(const=c, slope=m)

    def add_observer(self, *obj, domain=None, begin=None, end=None, autoremove=False, prioritize=False):
        if begin is None and end is None:
            return 0
        
        Curve._token_counter += 1
        token = Curve._token_counter
        domain = Interval.parse(domain, default_inf=True)
        obj_ref = None

        if len(obj) != 0:
            if autoremove:
                # Remove observer automatically
                obj_ref = weakref.ref(obj[0], lambda _: self.remove_observer(token))
            else:
                # Calling remove_observer() is required
                obj_ref = weakref.ref(obj[0])
        elif autoremove:
            raise Exception(&#39;Autoremoving an observer requires an object&#39;)

        # Do the callback functions require the domain?
        begin_with_interval = False
        end_with_interval = False
        if begin:
            begin_with_interval = util.count_positional_args(begin) == 1
        if end:
            end_with_interval = util.count_positional_args(end) == 1

        # TODO: does saving strong references to callbacks create a retain cycle?
        self._observer_data[token] = (obj_ref, domain, begin, end, begin_with_interval, end_with_interval)
        if prioritize:
            self._ordered_observer_tokens.insert(0, token)
        else:
            self._ordered_observer_tokens.append(token)
        return token

    def remove_observer(self, token_or_obj):
        if isinstance(token_or_obj, Number):
            if token_or_obj in self._observer_data:
                del self._observer_data[token_or_obj]
                self._ordered_observer_tokens.remove(token_or_obj)
        else:
            for token in list(self._ordered_observer_tokens):
                obj_ref = self._observer_data[token][0]
                if obj_ref is not None:
                    obj = obj_ref()
                    if obj is None or obj == token_or_obj:
                        del self._observer_data[token]
                        self._ordered_observer_tokens.remove(token)

    def begin_update(self, domain):
        if domain.is_empty or self._begin_update_interval.is_superset_of(domain):
            return
        self._begin_update_interval = Interval.union([self._begin_update_interval, domain])
        for token in self._ordered_observer_tokens:
            _, callback_interval, callback, _, callback_with_interval, _ = self._observer_data[token]
            if callback_interval is None or domain.intersects(callback_interval):
                if callback is not None:
                    if callback_with_interval:
                        callback(domain)
                    else:
                        callback()

    def end_update(self, domain):
        if domain.is_empty or self._end_update_interval.is_superset_of(domain):
            return
        self._end_update_interval = Interval.union([self._end_update_interval, domain])
        if not self._end_update_interval.is_superset_of(self._begin_update_interval):
            # Keep collecting updates
            return
        
        # Updates complete
        update_interval = self._end_update_interval
        self._begin_update_interval = Interval.empty()
        self._end_update_interval = Interval.empty()
        self.set_needs_interval_update()
        for token in list(self._ordered_observer_tokens):
            _, callback_interval, _, callback, _, callback_with_interval = self._observer_data[token]
            if callback_interval is None or update_interval.intersects(callback_interval):
                if callback is not None:
                    if callback_with_interval:
                        callback(update_interval)
                    else:
                        callback()

    @property
    def needs_domain_update(self):
        return self._domain is None

    def set_needs_interval_update(self):
        self._domain = None

    def map(self, tfm, skip_none=False, name=None, **kwargs):
        from .map import Map
        return Map(self, tfm, skip_none=skip_none, name=name, **kwargs)

    def accumulator_map(self, tfm, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
        from .accumulator_map import AccumulatorMap
        return AccumulatorMap(
            self,
            tfm,
            degree,
            is_period=is_period,
            interpolation=interpolation,
            min_step=min_step,
            uniform=uniform
        )

    def offset(self, x, duration=None):
        from .offset import Offset
        return Offset(self, x, duration=duration)

    def add(self, func):
        return Curve.add_many([self, func])

    def subtract(self, func):
        return Curve.subtract_many([self, func])

    def multiply(self, func):
        return Curve.multiply_many([self, func])

    def divide(self, func):
        return Curve.divide_many([self, func])

    def pow(self, power):
        return type(self).pow_many([self, power])

    def raised(self, base):
        return type(self).pow_many([base, self])

    def log(self, base=math.e):
        return type(self).log_many([self, base])

    def integral(self, const=0, interpolation=None, uniform=True):
        from .integral import Integral

        return Integral(self, const=const, interpolation=interpolation, uniform=uniform)

    def additive_inverse(self):
        return self.map(_additive_inverse)

    def multiplicative_inverse(self):
        return self.map(_multiplicative_inverse)

    def abs(self):
        return self.map(_abs)

    def blend(self, func, x_blend_start, x_blend_stop):
        from .aggregate import Aggregate
        from .piecewise import Piecewise
        
        x_blend_period = x_blend_stop - x_blend_start
        def blend_f(x, ys):
            u = (x - x_blend_start) / x_blend_period
            return (1.0 - u) * ys[0] + u * ys[1]
        c = Aggregate([self, func], tfm=blend_f, name=&#39;blend&#39;)

        funcs = [self, c, func]
        domains = self.domain.partition([x_blend_start, x_blend_stop])
        return Piecewise(funcs, domains)

    def extension(self, name, start=False, end=True, raise_on_empty=False, **kwds):
        from .extension import ConstantExtension
        from .extension import TangentExtension
        from .extension import SinExtension
        from .extension import HarmonicExtension
        from .extension import WeaveExtension

        classes = [            
            ConstantExtension,
            TangentExtension,
            SinExtension,
            HarmonicExtension,
            WeaveExtension
        ]

        for c in classes:
            if c.name == name:
                return c(self, start=start, end=end, raise_on_empty=raise_on_empty, **kwds)
        
        raise Exception(&#39;Unknown extension type&#39;)

    # def wave_extended(self, ref_func, min_deviation=0, start=None, step=None, min_step=MIN_STEP):
    #     if self.domain.is_positive_infinite:
    #         return self
    #     ref_func = Curve.parse(ref_func)
    #     extremas = Extremas(self, ref_func, min_deviation=min_deviation, start=start, step=step, min_step=min_step)

    # def mom(self, degree, duration, **kwargs):
    #     &#34;&#34;&#34;
    #     Returns the momentum of the reciever.

    #     The degree corresponds to the number of steps to take.
    #     &#34;&#34;&#34;
    #     degree = int(degree)
    #     if degree &lt; 1:
    #         raise ValueError(f&#39;Momentum requires a positive degree, got: {degree}&#39;)
    #     from pyduration import Duration
    #     duration = Duration.parse(duration)
    #     def _mom(x, y):
    #         if y is None:
    #             return None
    #         # step back
    #         x0 = duration.step(x, -degree)
    #         y0 = self.y(x0)
    #         if y0 is None:
    #             return None
    #         return y - y0
    #     return self.map(_mom, name=f&#39;mom({degree})&#39;, **kwargs)

    def sma(self, degree, is_period=False, **kwargs):
        from .sma import SMA
        return SMA(self, degree, is_period=is_period, **kwargs)

    def ema(self, degree, is_period=False, init=None, **kwargs):
        from .ema import EMA
        return EMA(self, degree, is_period=is_period, init=init, **kwargs)

    def smma(self, degree, **kwargs):
        from .sma import SMA
        from .ema import EMA
        sma = SMA(self, degree, is_period=False, **kwargs)
        ema = EMA(self, 1 / degree, is_period=False, init=sma, **kwargs)
        return ema

    def harmonic_smas(self, base_degree, count, stride=1, is_period=False, **kwargs):
        &#34;&#34;&#34;
        Returns `count` SMAs from small to large. Their degrees
        are proportional to the golden ratio.
        &#34;&#34;&#34;
        periods = []
        smas = []
        step = stride + 1

        for i in range(count):
            period = base_degree * GOLD ** float(i * step)
            period = round(period / base_degree) * base_degree
            periods.append(period)

        for i in range(count):
            period = periods[i]
            sma = self.sma(period, is_period=is_period, **kwargs)
            smas.append(sma)

        return smas

    def centered_macs(self, base_degree, count, stride=1, is_period=False, **kwargs):
        periods = []
        smas = []
        step = stride + 1

        for i in range(count):
            period = base_degree * GOLD ** float(i * step)
            period = round(period / base_degree) * base_degree
            periods.insert(0, period)

        for i in range(count):
            period = periods[i]
            sma = self.sma(period, is_period=is_period, **kwargs)
            smas.append(sma)

        return smas

    def rsi(self, degree, **kwargs):
        d = self.differential()
        du = Curve.max([d, 0], ignore_empty=False)
        dd = Curve.max([-d, 0], ignore_empty=False)
        rs = du.ema(1 / degree, **kwargs) / dd.ema(1 / degree, **kwargs)
        rsi = 100 - 100 / (1 + rs)
        rsi.name = f&#39;rsi({degree})&#39;
        return rsi

    def trailing_min(self, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
        return self.accumulator_map(
            min,
            degree,
            is_period=is_period,
            interpolation=interpolation,
            min_step=min_step,
            uniform=uniform
        )

    def trailing_max(self, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
        return self.accumulator_map(
            max,
            degree,
            is_period=is_period,
            interpolation=interpolation,
            min_step=min_step,
            uniform=uniform
        )

    def differential(self, forward=False):
        from .map import Map
        d = Map(self, lambda x, y: self.d_y(x, forward=forward))
        d.name = &#39;diff&#39;
        return d

    def subset(self, domain):
        from .generic import Generic
        return Generic(self, domain=domain, min_step=self.min_step)

    @classmethod
    def first(cls, funcs, *args):
        &#34;&#34;&#34;
        Return a func which returns the first value which is not `None`.
        &#34;&#34;&#34;
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def first_val(x, vals):
            for v in vals:
                if v is not None:
                    return v
            return None

        funcs = Curve.parse_many(funcs)
        return Aggregate(funcs, tfm=first_val, union=True, name=&#39;first&#39;)        

    @classmethod
    def min(cls, funcs, *args, ignore_empty=False):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def min_vals(x, vals):
            best = None
            for val in vals:
                if best is None or (val is not None and val &lt; best):
                    best = val
            return best

        def min_vals_with_empty(x, vals):
            return min(filter(lambda y: y is not None, vals), default=None)

        funcs = Curve.parse_many(funcs)
        t = min_vals_with_empty if ignore_empty else min_vals
        return Aggregate(funcs, tfm=t, union=ignore_empty, name=&#39;min&#39;)

    @classmethod
    def max(cls, funcs, *args, ignore_empty=False):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def max_vals(x, vals):
            best = None
            for val in vals:
                if best is None or (val is not None and val &gt; best):
                    best = val
            return best

        def max_vals_with_empty(x, vals):
            return max(filter(lambda y: y is not None, vals), default=None)

        funcs = Curve.parse_many(funcs)
        t = max_vals_with_empty if ignore_empty else max_vals
        return Aggregate(funcs, tfm=t, union=ignore_empty, name=&#39;max&#39;)

    @classmethod
    def add_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def add_f(x, ys):
            for y in ys:
                if y is None:
                    return None
            return sum(ys)
        return Aggregate(funcs, tfm=add_f, name=&#39;add&#39;, operator=&#39;+&#39;)

    @classmethod
    def subtract_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def sub_f(x, ys):
            result = 0
            for i, y in enumerate(ys):
                if y is None:
                    return None
                if i == 0:
                    result = y
                else:
                    result -= y
            return result
        return Aggregate(funcs, tfm=sub_f, name=&#39;sub&#39;, operator=&#39;-&#39;)

    @classmethod
    def multiply_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def mult_f(x, ys):
            geo_sum = 1.0
            for y in ys:
                if y is None:
                    return None
                geo_sum *= y
            return geo_sum
        return Aggregate(funcs, tfm=mult_f, name=&#39;mult&#39;, operator=&#39;*&#39;)

    @classmethod
    def divide_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def div_f(x, ys):
            result = 0
            for i, y in enumerate(ys):
                if y is None:
                    return None
                if i == 0:
                    result = y
                elif y == 0:
                    result = math.inf if result &gt;= 0 else -math.inf
                else:
                    result /= y
            return result
        return Aggregate(funcs, tfm=div_f, name=&#39;div&#39;, operator=&#39;/&#39;)

    @classmethod
    def pow_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def log_f(x, ys):
            result = 0
            for i, y in enumerate(ys):
                if y is None:
                    return None
                if i == 0:
                    result = y
                else:
                    result = result ** y
            return result
        return Aggregate(funcs, tfm=log_f, name=&#39;pow&#39;, operator=&#39;^&#39;)

    @classmethod
    def log_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def log_f(x, ys):
            result = 0
            for i, y in enumerate(ys):
                if y is None:
                    return None
                if i == 0:
                    result = y
                else:
                    result = math.log(result, y)
            return result
        return Aggregate(funcs, tfm=log_f, name=&#39;log&#39;)

    @classmethod
    def zero(cls, value):
        from .constant import Constant
        return Constant.zero()

    @classmethod
    def const(cls, value):
        from .constant import Constant
        return Constant(value)

    @classmethod
    def parse(cls, func):
        from .generic import Generic
        from .constant import Constant
        from .points import Points

        if func is None:
            return None
        elif isinstance(func, Curve):
            return func
        elif callable(func):
            return Generic(func)
        elif isinstance(func, Number):
            return Constant(func)
        elif isinstance(func, Sequence):
            # Parse points
            if len(func) == 0:
                return Points(func)
            else:
                if isinstance(func[0], Sequence):
                    if len(func[0]) == 2:
                        return Points(func)
        elif isinstance(func, Mapping):
            return cls.parse_descriptor(func)
        raise Exception(&#39;Unable to parse function&#39;)

    @classmethod
    def parse_descriptor(cls, d, fragment=False, current_func=None, decorators=None):
        # Example:
        # {
        #     &#34;$line&#34;: {
        #         &#34;points&#34;: [
        #             [&#34;2020-02-12 01:23+1200&#34;, 8765.56],
        #             [&#34;2020-02-30 04:50+1200&#34;, 6765.56]
        #         ]
        #     }
        # }
        if decorators is None:
            decorators = []

        def next_func_constructor(fname):
            f = current_func or _func_obj
            assert isinstance(f, Curve)
            ftype = type(f)
            fconstructor = None
            fconstructor_from_instance = False
            type_method_names = list(map(lambda x: x[0], inspect.getmembers(ftype, predicate=inspect.ismethod)))
            f_method_names = list(map(lambda x: x[0], inspect.getmembers(f, predicate=inspect.ismethod)))
            if f&#39;{fname}_many&#39; in type_method_names:
                fname = f&#39;{fname}_many&#39;
            if fname in type_method_names:
                def _create_class_fconstructor(fname):
                    def _class_fconstructor(*args, **kwargs):
                        f = current_func or _func_obj
                        fmethod = getattr(type(f), fname)
                        return fmethod(*args, **kwargs)
                    return _class_fconstructor
                fconstructor = _create_class_fconstructor(fname)
                fconstructor_from_instance = False
            elif fname in f_method_names:
                def _create_fconstructor(fname):
                    def _fconstructor(*args, **kwargs):
                        f = current_func or _func_obj
                        fmethod = getattr(f, fname)
                        return fmethod(*args, **kwargs)
                    return _fconstructor
                fconstructor = _create_fconstructor(fname)
                fconstructor_from_instance = True
            else:
                raise ValueError(f&#39;Bad function name: {fname}&#39;)
            return fconstructor, fconstructor_from_instance
        
        if isinstance(d, Mapping):
            fragment_vals = {}

            for k, v in d.items():

                if k.startswith(&#39;@&#39;):
                    # This is an decorator descriptor
                    oname = k[1:]
                    decorator_i = len(decorators)
                    decorators.insert(decorator_i, oname)
                    v = cls.parse_descriptor(v,
                        fragment=fragment,
                        current_func=current_func,
                        decorators=decorators
                    )
                    del decorators[decorator_i]

                    if oname.startswith(&#39;log&#39;):
                        # Log space has ended, exit log space
                        # by raising to power
                        base_str = oname[3:]
                        base = int(base_str) if bool(base_str) else math.e
                        v = base ** v
                    
                    if isinstance(v, Curve):
                        # Allow chaining
                        current_func = v
                        continue
                    if oname != &#39;args&#39;:
                        # Only let @args pass through to parent
                        if len(d) != 1:
                            raise ValueError(f&#39;A decorator (@...) can only have siblings in a fragment&#39;)
                        return v

                elif k.startswith(&#39;$&#39;):
                    # This is function descriptor
                    fname = k[1:]

                    fconstructor = None
                    fconstructor_from_instance = False

                    if fname == &#39;const&#39; or fname == &#39;constant&#39;:
                        from .constant import Constant
                        fconstructor = Constant
                    elif fname == &#39;line&#39;:
                        from .line import Line
                        fconstructor = Line
                    elif fname.startswith(&#39;log&#39;):
                        base_str = fname[3:]
                        base = int(base_str) if bool(base_str) else math.e
                        def _dot_log(*args, **kwargs):
                            return current_func.log(**util.extend({ &#34;base&#34;: base }, kwargs))
                        fconstructor = _dot_log
                        fconstructor_from_instance = True
                    else:
                        fconstructor, fconstructor_from_instance = next_func_constructor(fname)

                    func_args = cls.parse_descriptor(v,
                        fragment=True,
                        decorators=decorators
                    )
                    args = []
                    kwargs = {}
                    if isinstance(func_args, dict):
                        kwargs = func_args
                    elif isinstance(func_args, list):
                        args = func_args
                    else:
                        args = [func_args]
                    
                    # Check for nested args
                    if &#39;@args&#39; in kwargs:
                        args = kwargs[&#39;@args&#39;]
                        del kwargs[&#39;@args&#39;]

                    if fconstructor_from_instance and current_func is None:
                        current_func = Curve.parse(args[0])
                        del args[0]
                    elif not fconstructor_from_instance and current_func is not None:
                        # Add current function as first argument or to
                        # list at first argument
                        if bool(args) and isinstance(args[0], list):
                            args[0][0:0] = [current_func]
                        else:
                            args[0:0] = [current_func]
                    current_func = fconstructor(*args, **kwargs)
                    continue

                if current_func is not None:
                    raise Exception(f&#39;Unexpected key after a function: {k}&#39;)

                if isinstance(v, Mapping):
                    fragment_vals[k] = cls.parse_descriptor(v,
                        fragment=True,
                        decorators=decorators
                    )
                elif isinstance(v, Sequence) and not isinstance(v, (str, bytes)):
                    fragment_vals[k] = cls.parse_descriptor(v,
                        fragment=True,
                        decorators=decorators
                    )
                else:
                    fragment_vals[k] = v
            
            return current_func or fragment_vals
        elif fragment:
            if isinstance(d, Mapping):
                return {k: cls.parse_descriptor(v,
                    fragment=True,
                    decorators=decorators
                ) for k, v in d.items()}
            elif isinstance(d, Sequence) and not isinstance(d, (str, bytes)):
                return [cls.parse_descriptor(v,
                    fragment=True,
                    decorators=decorators
                ) for v in d]
            elif &#39;date&#39; in decorators:
                return arrow.get(d).timestamp
            elif isinstance(d, Number):
                if &#39;log&#39; in decorators:
                    return math.log(d)
                elif &#39;log2&#39; in decorators:
                    return math.log(d, 2)
                elif &#39;log10&#39; in decorators:
                    return math.log(d, 10)
                else:
                    return d
            else:
                return d
        else:
            raise TypeError(&#39;Unexpected type found while parsing a function&#39;)

    @classmethod
    def parse_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        return list(map(cls.parse, funcs))

    @classmethod
    def count_positional_args(cls, f, default=1):
        if not callable(f):
            raise Exception(&#39;Expected callable function&#39;)
        if inspect.isbuiltin(f):
            return default
        sig = inspect.signature(f)
        count = 0
        for param in sig.parameters.values():
            if param.kind == inspect.Parameter.POSITIONAL_ONLY or \
                param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:
                count += 1
        return count

    def __add__(self, other):
        return Curve.add_many([self, other])

    def __sub__(self, other):
        return Curve.subtract_many([self, other])

    def __mul__(self, other):
        return Curve.multiply_many([self, other])

    def __truediv__(self, other):
        return Curve.divide_many([self, other])

    def __pow__(self, other):
        return Curve.pow_many([self, other])

    def __radd__(self, other):
        return Curve.add_many([other, self])

    def __rsub__(self, other):
        return Curve.subtract_many([other, self])

    def __rmul__(self, other):
        return Curve.multiply_many([other, self])

    def __rtruediv__(self, other):
        return Curve.divide_many([other, self])

    def __rpow__(self, other):
        return Curve.pow_many([other, self])

    def __neg__(self):
        return self.additive_inverse()

    def __pos__(self):
        return self

    def __abs__(self):
        return self.abs()

def _additive_inverse(x, y):
    if y is None:
        return None
    return -y

def _multiplicative_inverse(x, y):
    if y is None:
        return None
    return 1 / y

def _abs(x, y):
    if y is None:
        return None
    return abs(y)

def _callable_arg_len(f, vararg_ret_val):
    args, varargs, _, _ = inspect.getargspec(f)
    if varargs is not None:
        return vararg_ret_val
    arg_len = len(args)
    if arg_len == 0:
        return 0
    if args[0] == &#39;self&#39;:
        arg_len -= 1
    return arg_len

_func_obj = Curve()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="curvepy.curve.Curve"><code class="flex name class">
<span>class <span class="ident">Curve</span></span>
<span>(</span><span>min_step=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Curve:

    _token_counter = 0

    @classmethod
    def empty(cls):
        from .empty import Empty
        return Empty()

    @property
    def min_step(self):
        return self._min_step

    @min_step.setter
    def min_step(self, value):
        self._min_step = value

    @property
    def domain(self):
        if self.needs_domain_update:
            self._domain = self.get_domain()
        return self._domain

    @property
    def update_interval(self):
        return self._begin_update_interval

    @property
    def is_updating(self):
        return not self.update_interval.is_empty

    def __init__(self, min_step=None):
        self.name = None
        self._domain = None
        self._observer_data = {}
        self._ordered_observer_tokens = []
        self._begin_update_interval = Interval.empty()
        self._end_update_interval = Interval.empty()
        self.min_step = min_step

    def __call__(self, *args):
        return self.y(args[0])

    def __repr__(self):
        try:
            if bool(self.name):
                return self.name
            return f&#39;{type(self).__name__}(&#34;{self.domain}&#34;)&#39;
        except Exception as e:
            return super().__repr__() + f&#39;({e})&#39;

    def y(self, x):
        raise Exception(&#34;Not implemented&#34;)

    def y_start(self):
        return self.y(self.domain.start)

    def y_end(self):
        return self.y(self.domain.end)

    def d_y(self, x, forward=False, min_step=MIN_STEP, limit=None):
        min_step = self.resolve_min_step(min_step)
        if forward:
            x1 = self.x_next(x, min_step=min_step, limit=limit)
        else:
            x1 = self.x_previous(x, min_step=min_step, limit=limit)

        if x1 is None:
            return None
        y1 = self.y(x1)
        if y1 is None:
            return None
        y = self.y(x)
        if y is None:
            return None
        if x1 == x:
            dy = math.inf if y1 &gt;= y else -math.inf
            if not forward:
                dy = -dy
        else:
            dy = (y1 - y) / (x1 - x)
        return dy

    def x(self, y):
        raise Exception(&#34;Not implemented&#34;)

    def x_next(self, x, min_step=MIN_STEP, limit=None):
        min_step = self.resolve_min_step(min_step)
        if math.isinf(min_step):
            x1 = self.domain.end
        else:
            x1 = x + min_step
        if limit is not None and x1 &gt; limit:
            x1 = limit
        if not self.domain.contains(x1, enforce_start=False):
            return None
        return x1

    def x_previous(self, x, min_step=MIN_STEP, limit=None):
        min_step = self.resolve_min_step(min_step)
        if math.isinf(min_step):
            x1 = self.domain.start
        else:
            x1 = x - min_step
        if limit is not None and x1 &lt; limit:
            x1 = limit
        if not self.domain.contains(x1, enforce_end=False):
            return None
        return x1

    def previous_point(self, x, min_step=MIN_STEP):
        x1 = self.x_previous(x, min_step=min_step)
        if x1 is None:
            return None
        y1 = self.y(x1)
        return (x1, y1)

    def next_point(self, x, min_step=MIN_STEP):
        x1 = self.x_next(x, min_step=min_step)
        if x1 is None:
            return None
        y1 = self.y(x1)
        return (x1, y1)

    def get_domain(self):
        return Interval.empty()

    def resolve_min_step(self, min_step):
        if min_step is None and self.min_step is None:
            return None
        elif min_step is None:
            return self.min_step
        elif self.min_step is None:
            return min_step
        else:
            return max(min_step, self.min_step)

    def sample_points(self, domain=None, min_step=MIN_STEP, step=None):
        min_step = self.resolve_min_step(min_step)
        if domain is None:
            domain = self.domain
        else:
            domain = Interval.intersection([self.domain, domain])
        if domain.is_empty:
            return []
        elif not domain.is_finite:
            raise Exception(&#34;Cannot sample points on an infinite domain {}. Specify a finite domain.&#34;.format(domain))
        x_start, x_end = domain
        x_end_bin = round(x_end / min_step) if min_step is not None else x_end
        if domain.start_open:
            points = []
        else:
            points = [(x_start, self.y(x_start))]
        if step is not None:
            x = x_start + step
            while x &lt;= x_end:
                y = self.y(x)
                points.append((x, y))
                x += step
        elif min_step is not None and min_step &gt; 0:
            x = self.x_next(x_start, min_step=min_step, limit=x_end)
            while x is not None and x &lt;= x_end:
                y = self.y(x)
                points.append((x, y))
                x_bin = round(x / min_step) if min_step is not None else x
                if x_bin == x_end_bin:
                    break
                x1 = self.x_next(x, min_step=min_step, limit=x_end)
                if x1 is not None:
                    x1_bin = round(x1 / min_step) if min_step is not None else x1
                    if x1_bin &lt;= x_bin:
                        raise Exception(&#39;Next x value {} should be greater than the previous x value {} by at least the minimum step of {}&#39;.format(x1, x, min_step))
                x = x1

            if not domain.end_open and points[-1][0] != x_end:
                points.append((x_end, self.y(x_end)))
        else:
            raise Exception(&#34;Bad functions sample parameters.&#34;)

        return points

    def sample_points_from_x(self, x, limit, backward=False, open=False, min_step=None):
        assert limit is not None
        if limit &lt; 0:
            limit = -limit
            backward = not backward
        min_step = self.resolve_min_step(min_step)
        points = []
        x1 = x
        i = 0

        if not open:
            if x is None:
                return points
            y = self.y(x)
            if y is None:
                return points
            i += 1

        while limit is None or i &lt; limit:
            if not backward:
                x1 = self.x_next(x1, min_step=min_step)
            else:
                x1 = self.x_previous(x1, min_step=min_step)
            if x1 is None:
                break
            y1 = self.y(x1)
            if y1 is None:
                break
            points.append((x1, y1))
            i += 1

        return points

    def get_range(self, domain=None, **kwargs):
        points = self.sample_points(domain=domain, **kwargs)
        low = None
        high = None
        for p in points:
            if low is None or p[1] &lt; low:
                low = p[1]
            if high is None or p[1] &gt; high:
                high = p[1]
        if low is None or high is None:
            return Interval.empty()
        return Interval(low, high)

    def minimise(self, x, min_step=MIN_STEP, step=None, max_iterations=1000):
        x_min = x
        x_min_previous = None
        iterations = 0
        while iterations &lt; max_iterations:
            iterations += 1
            y = self.y(x_min)
            if y is None:
                return x_min_previous
            dy0 = self.d_y(x_min, forward=False)
            dy1 = self.d_y(x_min, forward=True)
            forward = True
            if dy0 is None and dy1 is None:
                return x_min
            elif dy0 is None:
                if dy1 &lt;= 0:
                    forward = True
                else:
                    # Sloping into null value
                    return None
            elif dy1 is None:
                if dy0 &gt;= 0:
                    forward = False
                else:
                    # Sloping into null value
                    return None
            else:
                if dy0 * dy1 &lt; 0 and dy0 &lt;= 0 and dy1 &gt;= 0:
                    # Found minimum
                    return x_min

                if dy0 * dy1 &lt; 0:
                    # Found maximum
                    forward = abs(dy0) &lt; abs(dy1)
                else:
                    # On slope
                    forward = dy1 &lt; 0

            x_min_previous = x_min
            if forward:
                if step is not None:
                    x_min += step
                else:
                    x_min = self.x_next(x_min, min_step=min_step)
            else:
                if step is not None:
                    x_min -= step
                else:
                    x_min = self.x_previous(x_min, min_step=min_step)
        return x_min

    def maximise(self, x, min_step=MIN_STEP, step=None, max_iterations=1000):
        x_max = x
        x_max_previous = None
        iterations = 0
        while iterations &lt; max_iterations:
            iterations += 1
            y = self.y(x_max)
            if y is None:
                return x_max_previous
            dy0 = self.d_y(x_max, forward=False)
            dy1 = self.d_y(x_max, forward=True)
            forward = True
            if dy0 is None and dy1 is None:
                return x_max
            elif dy0 is None:
                if dy1 &gt;= 0:
                    forward = True
                else:
                    # Sloping into null value
                    return None
            elif dy1 is None:
                if dy0 &lt;= 0:
                    forward = False
                else:
                    # Sloping into null value
                    return None
            else:
                if dy0 * dy1 &lt; 0 and dy0 &gt;= 0 and dy1 &lt;= 0:
                    # Found maximum
                    return x_max

                if dy0 * dy1 &lt; 0:
                    # Found minimum
                    forward = abs(dy0) &lt; abs(dy1)
                else:
                    # On slope
                    forward = dy1 &gt; 0

            x_max_previous = x_max
            if forward:
                if step is not None:
                    x_max += step
                else:
                    x_max = self.x_next(x_max, min_step=min_step)
            else:
                if step is not None:
                    x_max -= step
                else:
                    x_max = self.x_previous(x_max, min_step=min_step)
        return x_max

    def regression(self, domain=None, min_step=MIN_STEP, step=None):
        points = self.sample_points(domain=domain, min_step=min_step, step=step)
        for p in points:
            if p[1] is None:
                return None
        count = len(points)
        if count &lt; 2:
            return None
            
        from .line import Line
        if count == 2:
            return Line(p1=points[0], p2=points[1])
        xy = np.vstack(points)
        x = xy[:,0]
        y = xy[:,1]
        A = np.array([x, np.ones(count)])

        # Regression
        w = np.linalg.lstsq(A.T, y, rcond=None)[0]
        m = w[0]
        c = w[1]

        return Line(const=c, slope=m)

    def add_observer(self, *obj, domain=None, begin=None, end=None, autoremove=False, prioritize=False):
        if begin is None and end is None:
            return 0
        
        Curve._token_counter += 1
        token = Curve._token_counter
        domain = Interval.parse(domain, default_inf=True)
        obj_ref = None

        if len(obj) != 0:
            if autoremove:
                # Remove observer automatically
                obj_ref = weakref.ref(obj[0], lambda _: self.remove_observer(token))
            else:
                # Calling remove_observer() is required
                obj_ref = weakref.ref(obj[0])
        elif autoremove:
            raise Exception(&#39;Autoremoving an observer requires an object&#39;)

        # Do the callback functions require the domain?
        begin_with_interval = False
        end_with_interval = False
        if begin:
            begin_with_interval = util.count_positional_args(begin) == 1
        if end:
            end_with_interval = util.count_positional_args(end) == 1

        # TODO: does saving strong references to callbacks create a retain cycle?
        self._observer_data[token] = (obj_ref, domain, begin, end, begin_with_interval, end_with_interval)
        if prioritize:
            self._ordered_observer_tokens.insert(0, token)
        else:
            self._ordered_observer_tokens.append(token)
        return token

    def remove_observer(self, token_or_obj):
        if isinstance(token_or_obj, Number):
            if token_or_obj in self._observer_data:
                del self._observer_data[token_or_obj]
                self._ordered_observer_tokens.remove(token_or_obj)
        else:
            for token in list(self._ordered_observer_tokens):
                obj_ref = self._observer_data[token][0]
                if obj_ref is not None:
                    obj = obj_ref()
                    if obj is None or obj == token_or_obj:
                        del self._observer_data[token]
                        self._ordered_observer_tokens.remove(token)

    def begin_update(self, domain):
        if domain.is_empty or self._begin_update_interval.is_superset_of(domain):
            return
        self._begin_update_interval = Interval.union([self._begin_update_interval, domain])
        for token in self._ordered_observer_tokens:
            _, callback_interval, callback, _, callback_with_interval, _ = self._observer_data[token]
            if callback_interval is None or domain.intersects(callback_interval):
                if callback is not None:
                    if callback_with_interval:
                        callback(domain)
                    else:
                        callback()

    def end_update(self, domain):
        if domain.is_empty or self._end_update_interval.is_superset_of(domain):
            return
        self._end_update_interval = Interval.union([self._end_update_interval, domain])
        if not self._end_update_interval.is_superset_of(self._begin_update_interval):
            # Keep collecting updates
            return
        
        # Updates complete
        update_interval = self._end_update_interval
        self._begin_update_interval = Interval.empty()
        self._end_update_interval = Interval.empty()
        self.set_needs_interval_update()
        for token in list(self._ordered_observer_tokens):
            _, callback_interval, _, callback, _, callback_with_interval = self._observer_data[token]
            if callback_interval is None or update_interval.intersects(callback_interval):
                if callback is not None:
                    if callback_with_interval:
                        callback(update_interval)
                    else:
                        callback()

    @property
    def needs_domain_update(self):
        return self._domain is None

    def set_needs_interval_update(self):
        self._domain = None

    def map(self, tfm, skip_none=False, name=None, **kwargs):
        from .map import Map
        return Map(self, tfm, skip_none=skip_none, name=name, **kwargs)

    def accumulator_map(self, tfm, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
        from .accumulator_map import AccumulatorMap
        return AccumulatorMap(
            self,
            tfm,
            degree,
            is_period=is_period,
            interpolation=interpolation,
            min_step=min_step,
            uniform=uniform
        )

    def offset(self, x, duration=None):
        from .offset import Offset
        return Offset(self, x, duration=duration)

    def add(self, func):
        return Curve.add_many([self, func])

    def subtract(self, func):
        return Curve.subtract_many([self, func])

    def multiply(self, func):
        return Curve.multiply_many([self, func])

    def divide(self, func):
        return Curve.divide_many([self, func])

    def pow(self, power):
        return type(self).pow_many([self, power])

    def raised(self, base):
        return type(self).pow_many([base, self])

    def log(self, base=math.e):
        return type(self).log_many([self, base])

    def integral(self, const=0, interpolation=None, uniform=True):
        from .integral import Integral

        return Integral(self, const=const, interpolation=interpolation, uniform=uniform)

    def additive_inverse(self):
        return self.map(_additive_inverse)

    def multiplicative_inverse(self):
        return self.map(_multiplicative_inverse)

    def abs(self):
        return self.map(_abs)

    def blend(self, func, x_blend_start, x_blend_stop):
        from .aggregate import Aggregate
        from .piecewise import Piecewise
        
        x_blend_period = x_blend_stop - x_blend_start
        def blend_f(x, ys):
            u = (x - x_blend_start) / x_blend_period
            return (1.0 - u) * ys[0] + u * ys[1]
        c = Aggregate([self, func], tfm=blend_f, name=&#39;blend&#39;)

        funcs = [self, c, func]
        domains = self.domain.partition([x_blend_start, x_blend_stop])
        return Piecewise(funcs, domains)

    def extension(self, name, start=False, end=True, raise_on_empty=False, **kwds):
        from .extension import ConstantExtension
        from .extension import TangentExtension
        from .extension import SinExtension
        from .extension import HarmonicExtension
        from .extension import WeaveExtension

        classes = [            
            ConstantExtension,
            TangentExtension,
            SinExtension,
            HarmonicExtension,
            WeaveExtension
        ]

        for c in classes:
            if c.name == name:
                return c(self, start=start, end=end, raise_on_empty=raise_on_empty, **kwds)
        
        raise Exception(&#39;Unknown extension type&#39;)

    # def wave_extended(self, ref_func, min_deviation=0, start=None, step=None, min_step=MIN_STEP):
    #     if self.domain.is_positive_infinite:
    #         return self
    #     ref_func = Curve.parse(ref_func)
    #     extremas = Extremas(self, ref_func, min_deviation=min_deviation, start=start, step=step, min_step=min_step)

    # def mom(self, degree, duration, **kwargs):
    #     &#34;&#34;&#34;
    #     Returns the momentum of the reciever.

    #     The degree corresponds to the number of steps to take.
    #     &#34;&#34;&#34;
    #     degree = int(degree)
    #     if degree &lt; 1:
    #         raise ValueError(f&#39;Momentum requires a positive degree, got: {degree}&#39;)
    #     from pyduration import Duration
    #     duration = Duration.parse(duration)
    #     def _mom(x, y):
    #         if y is None:
    #             return None
    #         # step back
    #         x0 = duration.step(x, -degree)
    #         y0 = self.y(x0)
    #         if y0 is None:
    #             return None
    #         return y - y0
    #     return self.map(_mom, name=f&#39;mom({degree})&#39;, **kwargs)

    def sma(self, degree, is_period=False, **kwargs):
        from .sma import SMA
        return SMA(self, degree, is_period=is_period, **kwargs)

    def ema(self, degree, is_period=False, init=None, **kwargs):
        from .ema import EMA
        return EMA(self, degree, is_period=is_period, init=init, **kwargs)

    def smma(self, degree, **kwargs):
        from .sma import SMA
        from .ema import EMA
        sma = SMA(self, degree, is_period=False, **kwargs)
        ema = EMA(self, 1 / degree, is_period=False, init=sma, **kwargs)
        return ema

    def harmonic_smas(self, base_degree, count, stride=1, is_period=False, **kwargs):
        &#34;&#34;&#34;
        Returns `count` SMAs from small to large. Their degrees
        are proportional to the golden ratio.
        &#34;&#34;&#34;
        periods = []
        smas = []
        step = stride + 1

        for i in range(count):
            period = base_degree * GOLD ** float(i * step)
            period = round(period / base_degree) * base_degree
            periods.append(period)

        for i in range(count):
            period = periods[i]
            sma = self.sma(period, is_period=is_period, **kwargs)
            smas.append(sma)

        return smas

    def centered_macs(self, base_degree, count, stride=1, is_period=False, **kwargs):
        periods = []
        smas = []
        step = stride + 1

        for i in range(count):
            period = base_degree * GOLD ** float(i * step)
            period = round(period / base_degree) * base_degree
            periods.insert(0, period)

        for i in range(count):
            period = periods[i]
            sma = self.sma(period, is_period=is_period, **kwargs)
            smas.append(sma)

        return smas

    def rsi(self, degree, **kwargs):
        d = self.differential()
        du = Curve.max([d, 0], ignore_empty=False)
        dd = Curve.max([-d, 0], ignore_empty=False)
        rs = du.ema(1 / degree, **kwargs) / dd.ema(1 / degree, **kwargs)
        rsi = 100 - 100 / (1 + rs)
        rsi.name = f&#39;rsi({degree})&#39;
        return rsi

    def trailing_min(self, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
        return self.accumulator_map(
            min,
            degree,
            is_period=is_period,
            interpolation=interpolation,
            min_step=min_step,
            uniform=uniform
        )

    def trailing_max(self, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
        return self.accumulator_map(
            max,
            degree,
            is_period=is_period,
            interpolation=interpolation,
            min_step=min_step,
            uniform=uniform
        )

    def differential(self, forward=False):
        from .map import Map
        d = Map(self, lambda x, y: self.d_y(x, forward=forward))
        d.name = &#39;diff&#39;
        return d

    def subset(self, domain):
        from .generic import Generic
        return Generic(self, domain=domain, min_step=self.min_step)

    @classmethod
    def first(cls, funcs, *args):
        &#34;&#34;&#34;
        Return a func which returns the first value which is not `None`.
        &#34;&#34;&#34;
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def first_val(x, vals):
            for v in vals:
                if v is not None:
                    return v
            return None

        funcs = Curve.parse_many(funcs)
        return Aggregate(funcs, tfm=first_val, union=True, name=&#39;first&#39;)        

    @classmethod
    def min(cls, funcs, *args, ignore_empty=False):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def min_vals(x, vals):
            best = None
            for val in vals:
                if best is None or (val is not None and val &lt; best):
                    best = val
            return best

        def min_vals_with_empty(x, vals):
            return min(filter(lambda y: y is not None, vals), default=None)

        funcs = Curve.parse_many(funcs)
        t = min_vals_with_empty if ignore_empty else min_vals
        return Aggregate(funcs, tfm=t, union=ignore_empty, name=&#39;min&#39;)

    @classmethod
    def max(cls, funcs, *args, ignore_empty=False):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def max_vals(x, vals):
            best = None
            for val in vals:
                if best is None or (val is not None and val &gt; best):
                    best = val
            return best

        def max_vals_with_empty(x, vals):
            return max(filter(lambda y: y is not None, vals), default=None)

        funcs = Curve.parse_many(funcs)
        t = max_vals_with_empty if ignore_empty else max_vals
        return Aggregate(funcs, tfm=t, union=ignore_empty, name=&#39;max&#39;)

    @classmethod
    def add_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def add_f(x, ys):
            for y in ys:
                if y is None:
                    return None
            return sum(ys)
        return Aggregate(funcs, tfm=add_f, name=&#39;add&#39;, operator=&#39;+&#39;)

    @classmethod
    def subtract_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def sub_f(x, ys):
            result = 0
            for i, y in enumerate(ys):
                if y is None:
                    return None
                if i == 0:
                    result = y
                else:
                    result -= y
            return result
        return Aggregate(funcs, tfm=sub_f, name=&#39;sub&#39;, operator=&#39;-&#39;)

    @classmethod
    def multiply_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def mult_f(x, ys):
            geo_sum = 1.0
            for y in ys:
                if y is None:
                    return None
                geo_sum *= y
            return geo_sum
        return Aggregate(funcs, tfm=mult_f, name=&#39;mult&#39;, operator=&#39;*&#39;)

    @classmethod
    def divide_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def div_f(x, ys):
            result = 0
            for i, y in enumerate(ys):
                if y is None:
                    return None
                if i == 0:
                    result = y
                elif y == 0:
                    result = math.inf if result &gt;= 0 else -math.inf
                else:
                    result /= y
            return result
        return Aggregate(funcs, tfm=div_f, name=&#39;div&#39;, operator=&#39;/&#39;)

    @classmethod
    def pow_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def log_f(x, ys):
            result = 0
            for i, y in enumerate(ys):
                if y is None:
                    return None
                if i == 0:
                    result = y
                else:
                    result = result ** y
            return result
        return Aggregate(funcs, tfm=log_f, name=&#39;pow&#39;, operator=&#39;^&#39;)

    @classmethod
    def log_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        from .aggregate import Aggregate

        def log_f(x, ys):
            result = 0
            for i, y in enumerate(ys):
                if y is None:
                    return None
                if i == 0:
                    result = y
                else:
                    result = math.log(result, y)
            return result
        return Aggregate(funcs, tfm=log_f, name=&#39;log&#39;)

    @classmethod
    def zero(cls, value):
        from .constant import Constant
        return Constant.zero()

    @classmethod
    def const(cls, value):
        from .constant import Constant
        return Constant(value)

    @classmethod
    def parse(cls, func):
        from .generic import Generic
        from .constant import Constant
        from .points import Points

        if func is None:
            return None
        elif isinstance(func, Curve):
            return func
        elif callable(func):
            return Generic(func)
        elif isinstance(func, Number):
            return Constant(func)
        elif isinstance(func, Sequence):
            # Parse points
            if len(func) == 0:
                return Points(func)
            else:
                if isinstance(func[0], Sequence):
                    if len(func[0]) == 2:
                        return Points(func)
        elif isinstance(func, Mapping):
            return cls.parse_descriptor(func)
        raise Exception(&#39;Unable to parse function&#39;)

    @classmethod
    def parse_descriptor(cls, d, fragment=False, current_func=None, decorators=None):
        # Example:
        # {
        #     &#34;$line&#34;: {
        #         &#34;points&#34;: [
        #             [&#34;2020-02-12 01:23+1200&#34;, 8765.56],
        #             [&#34;2020-02-30 04:50+1200&#34;, 6765.56]
        #         ]
        #     }
        # }
        if decorators is None:
            decorators = []

        def next_func_constructor(fname):
            f = current_func or _func_obj
            assert isinstance(f, Curve)
            ftype = type(f)
            fconstructor = None
            fconstructor_from_instance = False
            type_method_names = list(map(lambda x: x[0], inspect.getmembers(ftype, predicate=inspect.ismethod)))
            f_method_names = list(map(lambda x: x[0], inspect.getmembers(f, predicate=inspect.ismethod)))
            if f&#39;{fname}_many&#39; in type_method_names:
                fname = f&#39;{fname}_many&#39;
            if fname in type_method_names:
                def _create_class_fconstructor(fname):
                    def _class_fconstructor(*args, **kwargs):
                        f = current_func or _func_obj
                        fmethod = getattr(type(f), fname)
                        return fmethod(*args, **kwargs)
                    return _class_fconstructor
                fconstructor = _create_class_fconstructor(fname)
                fconstructor_from_instance = False
            elif fname in f_method_names:
                def _create_fconstructor(fname):
                    def _fconstructor(*args, **kwargs):
                        f = current_func or _func_obj
                        fmethod = getattr(f, fname)
                        return fmethod(*args, **kwargs)
                    return _fconstructor
                fconstructor = _create_fconstructor(fname)
                fconstructor_from_instance = True
            else:
                raise ValueError(f&#39;Bad function name: {fname}&#39;)
            return fconstructor, fconstructor_from_instance
        
        if isinstance(d, Mapping):
            fragment_vals = {}

            for k, v in d.items():

                if k.startswith(&#39;@&#39;):
                    # This is an decorator descriptor
                    oname = k[1:]
                    decorator_i = len(decorators)
                    decorators.insert(decorator_i, oname)
                    v = cls.parse_descriptor(v,
                        fragment=fragment,
                        current_func=current_func,
                        decorators=decorators
                    )
                    del decorators[decorator_i]

                    if oname.startswith(&#39;log&#39;):
                        # Log space has ended, exit log space
                        # by raising to power
                        base_str = oname[3:]
                        base = int(base_str) if bool(base_str) else math.e
                        v = base ** v
                    
                    if isinstance(v, Curve):
                        # Allow chaining
                        current_func = v
                        continue
                    if oname != &#39;args&#39;:
                        # Only let @args pass through to parent
                        if len(d) != 1:
                            raise ValueError(f&#39;A decorator (@...) can only have siblings in a fragment&#39;)
                        return v

                elif k.startswith(&#39;$&#39;):
                    # This is function descriptor
                    fname = k[1:]

                    fconstructor = None
                    fconstructor_from_instance = False

                    if fname == &#39;const&#39; or fname == &#39;constant&#39;:
                        from .constant import Constant
                        fconstructor = Constant
                    elif fname == &#39;line&#39;:
                        from .line import Line
                        fconstructor = Line
                    elif fname.startswith(&#39;log&#39;):
                        base_str = fname[3:]
                        base = int(base_str) if bool(base_str) else math.e
                        def _dot_log(*args, **kwargs):
                            return current_func.log(**util.extend({ &#34;base&#34;: base }, kwargs))
                        fconstructor = _dot_log
                        fconstructor_from_instance = True
                    else:
                        fconstructor, fconstructor_from_instance = next_func_constructor(fname)

                    func_args = cls.parse_descriptor(v,
                        fragment=True,
                        decorators=decorators
                    )
                    args = []
                    kwargs = {}
                    if isinstance(func_args, dict):
                        kwargs = func_args
                    elif isinstance(func_args, list):
                        args = func_args
                    else:
                        args = [func_args]
                    
                    # Check for nested args
                    if &#39;@args&#39; in kwargs:
                        args = kwargs[&#39;@args&#39;]
                        del kwargs[&#39;@args&#39;]

                    if fconstructor_from_instance and current_func is None:
                        current_func = Curve.parse(args[0])
                        del args[0]
                    elif not fconstructor_from_instance and current_func is not None:
                        # Add current function as first argument or to
                        # list at first argument
                        if bool(args) and isinstance(args[0], list):
                            args[0][0:0] = [current_func]
                        else:
                            args[0:0] = [current_func]
                    current_func = fconstructor(*args, **kwargs)
                    continue

                if current_func is not None:
                    raise Exception(f&#39;Unexpected key after a function: {k}&#39;)

                if isinstance(v, Mapping):
                    fragment_vals[k] = cls.parse_descriptor(v,
                        fragment=True,
                        decorators=decorators
                    )
                elif isinstance(v, Sequence) and not isinstance(v, (str, bytes)):
                    fragment_vals[k] = cls.parse_descriptor(v,
                        fragment=True,
                        decorators=decorators
                    )
                else:
                    fragment_vals[k] = v
            
            return current_func or fragment_vals
        elif fragment:
            if isinstance(d, Mapping):
                return {k: cls.parse_descriptor(v,
                    fragment=True,
                    decorators=decorators
                ) for k, v in d.items()}
            elif isinstance(d, Sequence) and not isinstance(d, (str, bytes)):
                return [cls.parse_descriptor(v,
                    fragment=True,
                    decorators=decorators
                ) for v in d]
            elif &#39;date&#39; in decorators:
                return arrow.get(d).timestamp
            elif isinstance(d, Number):
                if &#39;log&#39; in decorators:
                    return math.log(d)
                elif &#39;log2&#39; in decorators:
                    return math.log(d, 2)
                elif &#39;log10&#39; in decorators:
                    return math.log(d, 10)
                else:
                    return d
            else:
                return d
        else:
            raise TypeError(&#39;Unexpected type found while parsing a function&#39;)

    @classmethod
    def parse_many(cls, funcs, *args):
        if not isinstance(funcs, Sequence):
            funcs = [funcs] + list(args)
        return list(map(cls.parse, funcs))

    @classmethod
    def count_positional_args(cls, f, default=1):
        if not callable(f):
            raise Exception(&#39;Expected callable function&#39;)
        if inspect.isbuiltin(f):
            return default
        sig = inspect.signature(f)
        count = 0
        for param in sig.parameters.values():
            if param.kind == inspect.Parameter.POSITIONAL_ONLY or \
                param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:
                count += 1
        return count

    def __add__(self, other):
        return Curve.add_many([self, other])

    def __sub__(self, other):
        return Curve.subtract_many([self, other])

    def __mul__(self, other):
        return Curve.multiply_many([self, other])

    def __truediv__(self, other):
        return Curve.divide_many([self, other])

    def __pow__(self, other):
        return Curve.pow_many([self, other])

    def __radd__(self, other):
        return Curve.add_many([other, self])

    def __rsub__(self, other):
        return Curve.subtract_many([other, self])

    def __rmul__(self, other):
        return Curve.multiply_many([other, self])

    def __rtruediv__(self, other):
        return Curve.divide_many([other, self])

    def __rpow__(self, other):
        return Curve.pow_many([other, self])

    def __neg__(self):
        return self.additive_inverse()

    def __pos__(self):
        return self

    def __abs__(self):
        return self.abs()</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="curvepy.aggregate.Aggregate" href="aggregate.html#curvepy.aggregate.Aggregate">Aggregate</a></li>
<li><a title="curvepy.constant.Constant" href="constant.html#curvepy.constant.Constant">Constant</a></li>
<li><a title="curvepy.empty.Empty" href="empty.html#curvepy.empty.Empty">Empty</a></li>
<li><a title="curvepy.extension.extension.Extension" href="extension/extension.html#curvepy.extension.extension.Extension">Extension</a></li>
<li><a title="curvepy.generic.Generic" href="generic.html#curvepy.generic.Generic">Generic</a></li>
<li><a title="curvepy.line.Line" href="line.html#curvepy.line.Line">Line</a></li>
<li><a title="curvepy.map.Map" href="map.html#curvepy.map.Map">Map</a></li>
<li><a title="curvepy.offset.Offset" href="offset.html#curvepy.offset.Offset">Offset</a></li>
<li><a title="curvepy.piecewise.Piecewise" href="piecewise.html#curvepy.piecewise.Piecewise">Piecewise</a></li>
<li><a title="curvepy.points.Points" href="points.html#curvepy.points.Points">Points</a></li>
<li><a title="curvepy.quotes.Quotes" href="quotes.html#curvepy.quotes.Quotes">Quotes</a></li>
<li><a title="curvepy.scan.Scan" href="scan.html#curvepy.scan.Scan">Scan</a></li>
<li><a title="curvepy.sin.Sin" href="sin.html#curvepy.sin.Sin">Sin</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="curvepy.curve.Curve.add_many"><code class="name flex">
<span>def <span class="ident">add_many</span></span>(<span>funcs, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def add_many(cls, funcs, *args):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def add_f(x, ys):
        for y in ys:
            if y is None:
                return None
        return sum(ys)
    return Aggregate(funcs, tfm=add_f, name=&#39;add&#39;, operator=&#39;+&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.const"><code class="name flex">
<span>def <span class="ident">const</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def const(cls, value):
    from .constant import Constant
    return Constant(value)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.count_positional_args"><code class="name flex">
<span>def <span class="ident">count_positional_args</span></span>(<span>f, default=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def count_positional_args(cls, f, default=1):
    if not callable(f):
        raise Exception(&#39;Expected callable function&#39;)
    if inspect.isbuiltin(f):
        return default
    sig = inspect.signature(f)
    count = 0
    for param in sig.parameters.values():
        if param.kind == inspect.Parameter.POSITIONAL_ONLY or \
            param.kind == inspect.Parameter.POSITIONAL_OR_KEYWORD:
            count += 1
    return count</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.divide_many"><code class="name flex">
<span>def <span class="ident">divide_many</span></span>(<span>funcs, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def divide_many(cls, funcs, *args):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def div_f(x, ys):
        result = 0
        for i, y in enumerate(ys):
            if y is None:
                return None
            if i == 0:
                result = y
            elif y == 0:
                result = math.inf if result &gt;= 0 else -math.inf
            else:
                result /= y
        return result
    return Aggregate(funcs, tfm=div_f, name=&#39;div&#39;, operator=&#39;/&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def empty(cls):
    from .empty import Empty
    return Empty()</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.first"><code class="name flex">
<span>def <span class="ident">first</span></span>(<span>funcs, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a func which returns the first value which is not <code>None</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def first(cls, funcs, *args):
    &#34;&#34;&#34;
    Return a func which returns the first value which is not `None`.
    &#34;&#34;&#34;
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def first_val(x, vals):
        for v in vals:
            if v is not None:
                return v
        return None

    funcs = Curve.parse_many(funcs)
    return Aggregate(funcs, tfm=first_val, union=True, name=&#39;first&#39;)        </code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.log_many"><code class="name flex">
<span>def <span class="ident">log_many</span></span>(<span>funcs, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def log_many(cls, funcs, *args):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def log_f(x, ys):
        result = 0
        for i, y in enumerate(ys):
            if y is None:
                return None
            if i == 0:
                result = y
            else:
                result = math.log(result, y)
        return result
    return Aggregate(funcs, tfm=log_f, name=&#39;log&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.max"><code class="name flex">
<span>def <span class="ident">max</span></span>(<span>funcs, *args, ignore_empty=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def max(cls, funcs, *args, ignore_empty=False):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def max_vals(x, vals):
        best = None
        for val in vals:
            if best is None or (val is not None and val &gt; best):
                best = val
        return best

    def max_vals_with_empty(x, vals):
        return max(filter(lambda y: y is not None, vals), default=None)

    funcs = Curve.parse_many(funcs)
    t = max_vals_with_empty if ignore_empty else max_vals
    return Aggregate(funcs, tfm=t, union=ignore_empty, name=&#39;max&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.min"><code class="name flex">
<span>def <span class="ident">min</span></span>(<span>funcs, *args, ignore_empty=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def min(cls, funcs, *args, ignore_empty=False):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def min_vals(x, vals):
        best = None
        for val in vals:
            if best is None or (val is not None and val &lt; best):
                best = val
        return best

    def min_vals_with_empty(x, vals):
        return min(filter(lambda y: y is not None, vals), default=None)

    funcs = Curve.parse_many(funcs)
    t = min_vals_with_empty if ignore_empty else min_vals
    return Aggregate(funcs, tfm=t, union=ignore_empty, name=&#39;min&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.multiply_many"><code class="name flex">
<span>def <span class="ident">multiply_many</span></span>(<span>funcs, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def multiply_many(cls, funcs, *args):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def mult_f(x, ys):
        geo_sum = 1.0
        for y in ys:
            if y is None:
                return None
            geo_sum *= y
        return geo_sum
    return Aggregate(funcs, tfm=mult_f, name=&#39;mult&#39;, operator=&#39;*&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.parse"><code class="name flex">
<span>def <span class="ident">parse</span></span>(<span>func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse(cls, func):
    from .generic import Generic
    from .constant import Constant
    from .points import Points

    if func is None:
        return None
    elif isinstance(func, Curve):
        return func
    elif callable(func):
        return Generic(func)
    elif isinstance(func, Number):
        return Constant(func)
    elif isinstance(func, Sequence):
        # Parse points
        if len(func) == 0:
            return Points(func)
        else:
            if isinstance(func[0], Sequence):
                if len(func[0]) == 2:
                    return Points(func)
    elif isinstance(func, Mapping):
        return cls.parse_descriptor(func)
    raise Exception(&#39;Unable to parse function&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.parse_descriptor"><code class="name flex">
<span>def <span class="ident">parse_descriptor</span></span>(<span>d, fragment=False, current_func=None, decorators=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_descriptor(cls, d, fragment=False, current_func=None, decorators=None):
    # Example:
    # {
    #     &#34;$line&#34;: {
    #         &#34;points&#34;: [
    #             [&#34;2020-02-12 01:23+1200&#34;, 8765.56],
    #             [&#34;2020-02-30 04:50+1200&#34;, 6765.56]
    #         ]
    #     }
    # }
    if decorators is None:
        decorators = []

    def next_func_constructor(fname):
        f = current_func or _func_obj
        assert isinstance(f, Curve)
        ftype = type(f)
        fconstructor = None
        fconstructor_from_instance = False
        type_method_names = list(map(lambda x: x[0], inspect.getmembers(ftype, predicate=inspect.ismethod)))
        f_method_names = list(map(lambda x: x[0], inspect.getmembers(f, predicate=inspect.ismethod)))
        if f&#39;{fname}_many&#39; in type_method_names:
            fname = f&#39;{fname}_many&#39;
        if fname in type_method_names:
            def _create_class_fconstructor(fname):
                def _class_fconstructor(*args, **kwargs):
                    f = current_func or _func_obj
                    fmethod = getattr(type(f), fname)
                    return fmethod(*args, **kwargs)
                return _class_fconstructor
            fconstructor = _create_class_fconstructor(fname)
            fconstructor_from_instance = False
        elif fname in f_method_names:
            def _create_fconstructor(fname):
                def _fconstructor(*args, **kwargs):
                    f = current_func or _func_obj
                    fmethod = getattr(f, fname)
                    return fmethod(*args, **kwargs)
                return _fconstructor
            fconstructor = _create_fconstructor(fname)
            fconstructor_from_instance = True
        else:
            raise ValueError(f&#39;Bad function name: {fname}&#39;)
        return fconstructor, fconstructor_from_instance
    
    if isinstance(d, Mapping):
        fragment_vals = {}

        for k, v in d.items():

            if k.startswith(&#39;@&#39;):
                # This is an decorator descriptor
                oname = k[1:]
                decorator_i = len(decorators)
                decorators.insert(decorator_i, oname)
                v = cls.parse_descriptor(v,
                    fragment=fragment,
                    current_func=current_func,
                    decorators=decorators
                )
                del decorators[decorator_i]

                if oname.startswith(&#39;log&#39;):
                    # Log space has ended, exit log space
                    # by raising to power
                    base_str = oname[3:]
                    base = int(base_str) if bool(base_str) else math.e
                    v = base ** v
                
                if isinstance(v, Curve):
                    # Allow chaining
                    current_func = v
                    continue
                if oname != &#39;args&#39;:
                    # Only let @args pass through to parent
                    if len(d) != 1:
                        raise ValueError(f&#39;A decorator (@...) can only have siblings in a fragment&#39;)
                    return v

            elif k.startswith(&#39;$&#39;):
                # This is function descriptor
                fname = k[1:]

                fconstructor = None
                fconstructor_from_instance = False

                if fname == &#39;const&#39; or fname == &#39;constant&#39;:
                    from .constant import Constant
                    fconstructor = Constant
                elif fname == &#39;line&#39;:
                    from .line import Line
                    fconstructor = Line
                elif fname.startswith(&#39;log&#39;):
                    base_str = fname[3:]
                    base = int(base_str) if bool(base_str) else math.e
                    def _dot_log(*args, **kwargs):
                        return current_func.log(**util.extend({ &#34;base&#34;: base }, kwargs))
                    fconstructor = _dot_log
                    fconstructor_from_instance = True
                else:
                    fconstructor, fconstructor_from_instance = next_func_constructor(fname)

                func_args = cls.parse_descriptor(v,
                    fragment=True,
                    decorators=decorators
                )
                args = []
                kwargs = {}
                if isinstance(func_args, dict):
                    kwargs = func_args
                elif isinstance(func_args, list):
                    args = func_args
                else:
                    args = [func_args]
                
                # Check for nested args
                if &#39;@args&#39; in kwargs:
                    args = kwargs[&#39;@args&#39;]
                    del kwargs[&#39;@args&#39;]

                if fconstructor_from_instance and current_func is None:
                    current_func = Curve.parse(args[0])
                    del args[0]
                elif not fconstructor_from_instance and current_func is not None:
                    # Add current function as first argument or to
                    # list at first argument
                    if bool(args) and isinstance(args[0], list):
                        args[0][0:0] = [current_func]
                    else:
                        args[0:0] = [current_func]
                current_func = fconstructor(*args, **kwargs)
                continue

            if current_func is not None:
                raise Exception(f&#39;Unexpected key after a function: {k}&#39;)

            if isinstance(v, Mapping):
                fragment_vals[k] = cls.parse_descriptor(v,
                    fragment=True,
                    decorators=decorators
                )
            elif isinstance(v, Sequence) and not isinstance(v, (str, bytes)):
                fragment_vals[k] = cls.parse_descriptor(v,
                    fragment=True,
                    decorators=decorators
                )
            else:
                fragment_vals[k] = v
        
        return current_func or fragment_vals
    elif fragment:
        if isinstance(d, Mapping):
            return {k: cls.parse_descriptor(v,
                fragment=True,
                decorators=decorators
            ) for k, v in d.items()}
        elif isinstance(d, Sequence) and not isinstance(d, (str, bytes)):
            return [cls.parse_descriptor(v,
                fragment=True,
                decorators=decorators
            ) for v in d]
        elif &#39;date&#39; in decorators:
            return arrow.get(d).timestamp
        elif isinstance(d, Number):
            if &#39;log&#39; in decorators:
                return math.log(d)
            elif &#39;log2&#39; in decorators:
                return math.log(d, 2)
            elif &#39;log10&#39; in decorators:
                return math.log(d, 10)
            else:
                return d
        else:
            return d
    else:
        raise TypeError(&#39;Unexpected type found while parsing a function&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.parse_many"><code class="name flex">
<span>def <span class="ident">parse_many</span></span>(<span>funcs, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def parse_many(cls, funcs, *args):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    return list(map(cls.parse, funcs))</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.pow_many"><code class="name flex">
<span>def <span class="ident">pow_many</span></span>(<span>funcs, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def pow_many(cls, funcs, *args):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def log_f(x, ys):
        result = 0
        for i, y in enumerate(ys):
            if y is None:
                return None
            if i == 0:
                result = y
            else:
                result = result ** y
        return result
    return Aggregate(funcs, tfm=log_f, name=&#39;pow&#39;, operator=&#39;^&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.subtract_many"><code class="name flex">
<span>def <span class="ident">subtract_many</span></span>(<span>funcs, *args)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def subtract_many(cls, funcs, *args):
    if not isinstance(funcs, Sequence):
        funcs = [funcs] + list(args)
    from .aggregate import Aggregate

    def sub_f(x, ys):
        result = 0
        for i, y in enumerate(ys):
            if y is None:
                return None
            if i == 0:
                result = y
            else:
                result -= y
        return result
    return Aggregate(funcs, tfm=sub_f, name=&#39;sub&#39;, operator=&#39;-&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.zero"><code class="name flex">
<span>def <span class="ident">zero</span></span>(<span>value)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def zero(cls, value):
    from .constant import Constant
    return Constant.zero()</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="curvepy.curve.Curve.domain"><code class="name">var <span class="ident">domain</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def domain(self):
    if self.needs_domain_update:
        self._domain = self.get_domain()
    return self._domain</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.is_updating"><code class="name">var <span class="ident">is_updating</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_updating(self):
    return not self.update_interval.is_empty</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.min_step"><code class="name">var <span class="ident">min_step</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def min_step(self):
    return self._min_step</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.needs_domain_update"><code class="name">var <span class="ident">needs_domain_update</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def needs_domain_update(self):
    return self._domain is None</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.update_interval"><code class="name">var <span class="ident">update_interval</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def update_interval(self):
    return self._begin_update_interval</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="curvepy.curve.Curve.abs"><code class="name flex">
<span>def <span class="ident">abs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def abs(self):
    return self.map(_abs)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.accumulator_map"><code class="name flex">
<span>def <span class="ident">accumulator_map</span></span>(<span>self, tfm, degree, is_period=False, interpolation=None, min_step=1e-05, uniform=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def accumulator_map(self, tfm, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
    from .accumulator_map import AccumulatorMap
    return AccumulatorMap(
        self,
        tfm,
        degree,
        is_period=is_period,
        interpolation=interpolation,
        min_step=min_step,
        uniform=uniform
    )</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add(self, func):
    return Curve.add_many([self, func])</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.add_observer"><code class="name flex">
<span>def <span class="ident">add_observer</span></span>(<span>self, *obj, domain=None, begin=None, end=None, autoremove=False, prioritize=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_observer(self, *obj, domain=None, begin=None, end=None, autoremove=False, prioritize=False):
    if begin is None and end is None:
        return 0
    
    Curve._token_counter += 1
    token = Curve._token_counter
    domain = Interval.parse(domain, default_inf=True)
    obj_ref = None

    if len(obj) != 0:
        if autoremove:
            # Remove observer automatically
            obj_ref = weakref.ref(obj[0], lambda _: self.remove_observer(token))
        else:
            # Calling remove_observer() is required
            obj_ref = weakref.ref(obj[0])
    elif autoremove:
        raise Exception(&#39;Autoremoving an observer requires an object&#39;)

    # Do the callback functions require the domain?
    begin_with_interval = False
    end_with_interval = False
    if begin:
        begin_with_interval = util.count_positional_args(begin) == 1
    if end:
        end_with_interval = util.count_positional_args(end) == 1

    # TODO: does saving strong references to callbacks create a retain cycle?
    self._observer_data[token] = (obj_ref, domain, begin, end, begin_with_interval, end_with_interval)
    if prioritize:
        self._ordered_observer_tokens.insert(0, token)
    else:
        self._ordered_observer_tokens.append(token)
    return token</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.additive_inverse"><code class="name flex">
<span>def <span class="ident">additive_inverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def additive_inverse(self):
    return self.map(_additive_inverse)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.begin_update"><code class="name flex">
<span>def <span class="ident">begin_update</span></span>(<span>self, domain)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def begin_update(self, domain):
    if domain.is_empty or self._begin_update_interval.is_superset_of(domain):
        return
    self._begin_update_interval = Interval.union([self._begin_update_interval, domain])
    for token in self._ordered_observer_tokens:
        _, callback_interval, callback, _, callback_with_interval, _ = self._observer_data[token]
        if callback_interval is None or domain.intersects(callback_interval):
            if callback is not None:
                if callback_with_interval:
                    callback(domain)
                else:
                    callback()</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.blend"><code class="name flex">
<span>def <span class="ident">blend</span></span>(<span>self, func, x_blend_start, x_blend_stop)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def blend(self, func, x_blend_start, x_blend_stop):
    from .aggregate import Aggregate
    from .piecewise import Piecewise
    
    x_blend_period = x_blend_stop - x_blend_start
    def blend_f(x, ys):
        u = (x - x_blend_start) / x_blend_period
        return (1.0 - u) * ys[0] + u * ys[1]
    c = Aggregate([self, func], tfm=blend_f, name=&#39;blend&#39;)

    funcs = [self, c, func]
    domains = self.domain.partition([x_blend_start, x_blend_stop])
    return Piecewise(funcs, domains)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.centered_macs"><code class="name flex">
<span>def <span class="ident">centered_macs</span></span>(<span>self, base_degree, count, stride=1, is_period=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def centered_macs(self, base_degree, count, stride=1, is_period=False, **kwargs):
    periods = []
    smas = []
    step = stride + 1

    for i in range(count):
        period = base_degree * GOLD ** float(i * step)
        period = round(period / base_degree) * base_degree
        periods.insert(0, period)

    for i in range(count):
        period = periods[i]
        sma = self.sma(period, is_period=is_period, **kwargs)
        smas.append(sma)

    return smas</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.d_y"><code class="name flex">
<span>def <span class="ident">d_y</span></span>(<span>self, x, forward=False, min_step=1e-05, limit=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def d_y(self, x, forward=False, min_step=MIN_STEP, limit=None):
    min_step = self.resolve_min_step(min_step)
    if forward:
        x1 = self.x_next(x, min_step=min_step, limit=limit)
    else:
        x1 = self.x_previous(x, min_step=min_step, limit=limit)

    if x1 is None:
        return None
    y1 = self.y(x1)
    if y1 is None:
        return None
    y = self.y(x)
    if y is None:
        return None
    if x1 == x:
        dy = math.inf if y1 &gt;= y else -math.inf
        if not forward:
            dy = -dy
    else:
        dy = (y1 - y) / (x1 - x)
    return dy</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.differential"><code class="name flex">
<span>def <span class="ident">differential</span></span>(<span>self, forward=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def differential(self, forward=False):
    from .map import Map
    d = Map(self, lambda x, y: self.d_y(x, forward=forward))
    d.name = &#39;diff&#39;
    return d</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.divide"><code class="name flex">
<span>def <span class="ident">divide</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def divide(self, func):
    return Curve.divide_many([self, func])</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.ema"><code class="name flex">
<span>def <span class="ident">ema</span></span>(<span>self, degree, is_period=False, init=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ema(self, degree, is_period=False, init=None, **kwargs):
    from .ema import EMA
    return EMA(self, degree, is_period=is_period, init=init, **kwargs)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.end_update"><code class="name flex">
<span>def <span class="ident">end_update</span></span>(<span>self, domain)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def end_update(self, domain):
    if domain.is_empty or self._end_update_interval.is_superset_of(domain):
        return
    self._end_update_interval = Interval.union([self._end_update_interval, domain])
    if not self._end_update_interval.is_superset_of(self._begin_update_interval):
        # Keep collecting updates
        return
    
    # Updates complete
    update_interval = self._end_update_interval
    self._begin_update_interval = Interval.empty()
    self._end_update_interval = Interval.empty()
    self.set_needs_interval_update()
    for token in list(self._ordered_observer_tokens):
        _, callback_interval, _, callback, _, callback_with_interval = self._observer_data[token]
        if callback_interval is None or update_interval.intersects(callback_interval):
            if callback is not None:
                if callback_with_interval:
                    callback(update_interval)
                else:
                    callback()</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.extension"><code class="name flex">
<span>def <span class="ident">extension</span></span>(<span>self, name, start=False, end=True, raise_on_empty=False, **kwds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extension(self, name, start=False, end=True, raise_on_empty=False, **kwds):
    from .extension import ConstantExtension
    from .extension import TangentExtension
    from .extension import SinExtension
    from .extension import HarmonicExtension
    from .extension import WeaveExtension

    classes = [            
        ConstantExtension,
        TangentExtension,
        SinExtension,
        HarmonicExtension,
        WeaveExtension
    ]

    for c in classes:
        if c.name == name:
            return c(self, start=start, end=end, raise_on_empty=raise_on_empty, **kwds)
    
    raise Exception(&#39;Unknown extension type&#39;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.get_domain"><code class="name flex">
<span>def <span class="ident">get_domain</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_domain(self):
    return Interval.empty()</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.get_range"><code class="name flex">
<span>def <span class="ident">get_range</span></span>(<span>self, domain=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_range(self, domain=None, **kwargs):
    points = self.sample_points(domain=domain, **kwargs)
    low = None
    high = None
    for p in points:
        if low is None or p[1] &lt; low:
            low = p[1]
        if high is None or p[1] &gt; high:
            high = p[1]
    if low is None or high is None:
        return Interval.empty()
    return Interval(low, high)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.harmonic_smas"><code class="name flex">
<span>def <span class="ident">harmonic_smas</span></span>(<span>self, base_degree, count, stride=1, is_period=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns <code>count</code> SMAs from small to large. Their degrees
are proportional to the golden ratio.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def harmonic_smas(self, base_degree, count, stride=1, is_period=False, **kwargs):
    &#34;&#34;&#34;
    Returns `count` SMAs from small to large. Their degrees
    are proportional to the golden ratio.
    &#34;&#34;&#34;
    periods = []
    smas = []
    step = stride + 1

    for i in range(count):
        period = base_degree * GOLD ** float(i * step)
        period = round(period / base_degree) * base_degree
        periods.append(period)

    for i in range(count):
        period = periods[i]
        sma = self.sma(period, is_period=is_period, **kwargs)
        smas.append(sma)

    return smas</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.integral"><code class="name flex">
<span>def <span class="ident">integral</span></span>(<span>self, const=0, interpolation=None, uniform=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def integral(self, const=0, interpolation=None, uniform=True):
    from .integral import Integral

    return Integral(self, const=const, interpolation=interpolation, uniform=uniform)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.log"><code class="name flex">
<span>def <span class="ident">log</span></span>(<span>self, base=2.718281828459045)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def log(self, base=math.e):
    return type(self).log_many([self, base])</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.map"><code class="name flex">
<span>def <span class="ident">map</span></span>(<span>self, tfm, skip_none=False, name=None, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def map(self, tfm, skip_none=False, name=None, **kwargs):
    from .map import Map
    return Map(self, tfm, skip_none=skip_none, name=name, **kwargs)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.maximise"><code class="name flex">
<span>def <span class="ident">maximise</span></span>(<span>self, x, min_step=1e-05, step=None, max_iterations=1000)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def maximise(self, x, min_step=MIN_STEP, step=None, max_iterations=1000):
    x_max = x
    x_max_previous = None
    iterations = 0
    while iterations &lt; max_iterations:
        iterations += 1
        y = self.y(x_max)
        if y is None:
            return x_max_previous
        dy0 = self.d_y(x_max, forward=False)
        dy1 = self.d_y(x_max, forward=True)
        forward = True
        if dy0 is None and dy1 is None:
            return x_max
        elif dy0 is None:
            if dy1 &gt;= 0:
                forward = True
            else:
                # Sloping into null value
                return None
        elif dy1 is None:
            if dy0 &lt;= 0:
                forward = False
            else:
                # Sloping into null value
                return None
        else:
            if dy0 * dy1 &lt; 0 and dy0 &gt;= 0 and dy1 &lt;= 0:
                # Found maximum
                return x_max

            if dy0 * dy1 &lt; 0:
                # Found minimum
                forward = abs(dy0) &lt; abs(dy1)
            else:
                # On slope
                forward = dy1 &gt; 0

        x_max_previous = x_max
        if forward:
            if step is not None:
                x_max += step
            else:
                x_max = self.x_next(x_max, min_step=min_step)
        else:
            if step is not None:
                x_max -= step
            else:
                x_max = self.x_previous(x_max, min_step=min_step)
    return x_max</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.minimise"><code class="name flex">
<span>def <span class="ident">minimise</span></span>(<span>self, x, min_step=1e-05, step=None, max_iterations=1000)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def minimise(self, x, min_step=MIN_STEP, step=None, max_iterations=1000):
    x_min = x
    x_min_previous = None
    iterations = 0
    while iterations &lt; max_iterations:
        iterations += 1
        y = self.y(x_min)
        if y is None:
            return x_min_previous
        dy0 = self.d_y(x_min, forward=False)
        dy1 = self.d_y(x_min, forward=True)
        forward = True
        if dy0 is None and dy1 is None:
            return x_min
        elif dy0 is None:
            if dy1 &lt;= 0:
                forward = True
            else:
                # Sloping into null value
                return None
        elif dy1 is None:
            if dy0 &gt;= 0:
                forward = False
            else:
                # Sloping into null value
                return None
        else:
            if dy0 * dy1 &lt; 0 and dy0 &lt;= 0 and dy1 &gt;= 0:
                # Found minimum
                return x_min

            if dy0 * dy1 &lt; 0:
                # Found maximum
                forward = abs(dy0) &lt; abs(dy1)
            else:
                # On slope
                forward = dy1 &lt; 0

        x_min_previous = x_min
        if forward:
            if step is not None:
                x_min += step
            else:
                x_min = self.x_next(x_min, min_step=min_step)
        else:
            if step is not None:
                x_min -= step
            else:
                x_min = self.x_previous(x_min, min_step=min_step)
    return x_min</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.multiplicative_inverse"><code class="name flex">
<span>def <span class="ident">multiplicative_inverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiplicative_inverse(self):
    return self.map(_multiplicative_inverse)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.multiply"><code class="name flex">
<span>def <span class="ident">multiply</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def multiply(self, func):
    return Curve.multiply_many([self, func])</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.next_point"><code class="name flex">
<span>def <span class="ident">next_point</span></span>(<span>self, x, min_step=1e-05)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def next_point(self, x, min_step=MIN_STEP):
    x1 = self.x_next(x, min_step=min_step)
    if x1 is None:
        return None
    y1 = self.y(x1)
    return (x1, y1)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>self, x, duration=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def offset(self, x, duration=None):
    from .offset import Offset
    return Offset(self, x, duration=duration)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.pow"><code class="name flex">
<span>def <span class="ident">pow</span></span>(<span>self, power)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pow(self, power):
    return type(self).pow_many([self, power])</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.previous_point"><code class="name flex">
<span>def <span class="ident">previous_point</span></span>(<span>self, x, min_step=1e-05)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def previous_point(self, x, min_step=MIN_STEP):
    x1 = self.x_previous(x, min_step=min_step)
    if x1 is None:
        return None
    y1 = self.y(x1)
    return (x1, y1)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.raised"><code class="name flex">
<span>def <span class="ident">raised</span></span>(<span>self, base)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def raised(self, base):
    return type(self).pow_many([base, self])</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.regression"><code class="name flex">
<span>def <span class="ident">regression</span></span>(<span>self, domain=None, min_step=1e-05, step=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def regression(self, domain=None, min_step=MIN_STEP, step=None):
    points = self.sample_points(domain=domain, min_step=min_step, step=step)
    for p in points:
        if p[1] is None:
            return None
    count = len(points)
    if count &lt; 2:
        return None
        
    from .line import Line
    if count == 2:
        return Line(p1=points[0], p2=points[1])
    xy = np.vstack(points)
    x = xy[:,0]
    y = xy[:,1]
    A = np.array([x, np.ones(count)])

    # Regression
    w = np.linalg.lstsq(A.T, y, rcond=None)[0]
    m = w[0]
    c = w[1]

    return Line(const=c, slope=m)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.remove_observer"><code class="name flex">
<span>def <span class="ident">remove_observer</span></span>(<span>self, token_or_obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def remove_observer(self, token_or_obj):
    if isinstance(token_or_obj, Number):
        if token_or_obj in self._observer_data:
            del self._observer_data[token_or_obj]
            self._ordered_observer_tokens.remove(token_or_obj)
    else:
        for token in list(self._ordered_observer_tokens):
            obj_ref = self._observer_data[token][0]
            if obj_ref is not None:
                obj = obj_ref()
                if obj is None or obj == token_or_obj:
                    del self._observer_data[token]
                    self._ordered_observer_tokens.remove(token)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.resolve_min_step"><code class="name flex">
<span>def <span class="ident">resolve_min_step</span></span>(<span>self, min_step)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def resolve_min_step(self, min_step):
    if min_step is None and self.min_step is None:
        return None
    elif min_step is None:
        return self.min_step
    elif self.min_step is None:
        return min_step
    else:
        return max(min_step, self.min_step)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.rsi"><code class="name flex">
<span>def <span class="ident">rsi</span></span>(<span>self, degree, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rsi(self, degree, **kwargs):
    d = self.differential()
    du = Curve.max([d, 0], ignore_empty=False)
    dd = Curve.max([-d, 0], ignore_empty=False)
    rs = du.ema(1 / degree, **kwargs) / dd.ema(1 / degree, **kwargs)
    rsi = 100 - 100 / (1 + rs)
    rsi.name = f&#39;rsi({degree})&#39;
    return rsi</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.sample_points"><code class="name flex">
<span>def <span class="ident">sample_points</span></span>(<span>self, domain=None, min_step=1e-05, step=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_points(self, domain=None, min_step=MIN_STEP, step=None):
    min_step = self.resolve_min_step(min_step)
    if domain is None:
        domain = self.domain
    else:
        domain = Interval.intersection([self.domain, domain])
    if domain.is_empty:
        return []
    elif not domain.is_finite:
        raise Exception(&#34;Cannot sample points on an infinite domain {}. Specify a finite domain.&#34;.format(domain))
    x_start, x_end = domain
    x_end_bin = round(x_end / min_step) if min_step is not None else x_end
    if domain.start_open:
        points = []
    else:
        points = [(x_start, self.y(x_start))]
    if step is not None:
        x = x_start + step
        while x &lt;= x_end:
            y = self.y(x)
            points.append((x, y))
            x += step
    elif min_step is not None and min_step &gt; 0:
        x = self.x_next(x_start, min_step=min_step, limit=x_end)
        while x is not None and x &lt;= x_end:
            y = self.y(x)
            points.append((x, y))
            x_bin = round(x / min_step) if min_step is not None else x
            if x_bin == x_end_bin:
                break
            x1 = self.x_next(x, min_step=min_step, limit=x_end)
            if x1 is not None:
                x1_bin = round(x1 / min_step) if min_step is not None else x1
                if x1_bin &lt;= x_bin:
                    raise Exception(&#39;Next x value {} should be greater than the previous x value {} by at least the minimum step of {}&#39;.format(x1, x, min_step))
            x = x1

        if not domain.end_open and points[-1][0] != x_end:
            points.append((x_end, self.y(x_end)))
    else:
        raise Exception(&#34;Bad functions sample parameters.&#34;)

    return points</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.sample_points_from_x"><code class="name flex">
<span>def <span class="ident">sample_points_from_x</span></span>(<span>self, x, limit, backward=False, open=False, min_step=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sample_points_from_x(self, x, limit, backward=False, open=False, min_step=None):
    assert limit is not None
    if limit &lt; 0:
        limit = -limit
        backward = not backward
    min_step = self.resolve_min_step(min_step)
    points = []
    x1 = x
    i = 0

    if not open:
        if x is None:
            return points
        y = self.y(x)
        if y is None:
            return points
        i += 1

    while limit is None or i &lt; limit:
        if not backward:
            x1 = self.x_next(x1, min_step=min_step)
        else:
            x1 = self.x_previous(x1, min_step=min_step)
        if x1 is None:
            break
        y1 = self.y(x1)
        if y1 is None:
            break
        points.append((x1, y1))
        i += 1

    return points</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.set_needs_interval_update"><code class="name flex">
<span>def <span class="ident">set_needs_interval_update</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_needs_interval_update(self):
    self._domain = None</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.sma"><code class="name flex">
<span>def <span class="ident">sma</span></span>(<span>self, degree, is_period=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sma(self, degree, is_period=False, **kwargs):
    from .sma import SMA
    return SMA(self, degree, is_period=is_period, **kwargs)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.smma"><code class="name flex">
<span>def <span class="ident">smma</span></span>(<span>self, degree, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def smma(self, degree, **kwargs):
    from .sma import SMA
    from .ema import EMA
    sma = SMA(self, degree, is_period=False, **kwargs)
    ema = EMA(self, 1 / degree, is_period=False, init=sma, **kwargs)
    return ema</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.subset"><code class="name flex">
<span>def <span class="ident">subset</span></span>(<span>self, domain)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subset(self, domain):
    from .generic import Generic
    return Generic(self, domain=domain, min_step=self.min_step)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.subtract"><code class="name flex">
<span>def <span class="ident">subtract</span></span>(<span>self, func)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subtract(self, func):
    return Curve.subtract_many([self, func])</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.trailing_max"><code class="name flex">
<span>def <span class="ident">trailing_max</span></span>(<span>self, degree, is_period=False, interpolation=None, min_step=1e-05, uniform=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trailing_max(self, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
    return self.accumulator_map(
        max,
        degree,
        is_period=is_period,
        interpolation=interpolation,
        min_step=min_step,
        uniform=uniform
    )</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.trailing_min"><code class="name flex">
<span>def <span class="ident">trailing_min</span></span>(<span>self, degree, is_period=False, interpolation=None, min_step=1e-05, uniform=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def trailing_min(self, degree, is_period=False, interpolation=None, min_step=MIN_STEP, uniform=True):
    return self.accumulator_map(
        min,
        degree,
        is_period=is_period,
        interpolation=interpolation,
        min_step=min_step,
        uniform=uniform
    )</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.x"><code class="name flex">
<span>def <span class="ident">x</span></span>(<span>self, y)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x(self, y):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.x_next"><code class="name flex">
<span>def <span class="ident">x_next</span></span>(<span>self, x, min_step=1e-05, limit=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_next(self, x, min_step=MIN_STEP, limit=None):
    min_step = self.resolve_min_step(min_step)
    if math.isinf(min_step):
        x1 = self.domain.end
    else:
        x1 = x + min_step
    if limit is not None and x1 &gt; limit:
        x1 = limit
    if not self.domain.contains(x1, enforce_start=False):
        return None
    return x1</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.x_previous"><code class="name flex">
<span>def <span class="ident">x_previous</span></span>(<span>self, x, min_step=1e-05, limit=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def x_previous(self, x, min_step=MIN_STEP, limit=None):
    min_step = self.resolve_min_step(min_step)
    if math.isinf(min_step):
        x1 = self.domain.start
    else:
        x1 = x - min_step
    if limit is not None and x1 &lt; limit:
        x1 = limit
    if not self.domain.contains(x1, enforce_end=False):
        return None
    return x1</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.y"><code class="name flex">
<span>def <span class="ident">y</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y(self, x):
    raise Exception(&#34;Not implemented&#34;)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.y_end"><code class="name flex">
<span>def <span class="ident">y_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y_end(self):
    return self.y(self.domain.end)</code></pre>
</details>
</dd>
<dt id="curvepy.curve.Curve.y_start"><code class="name flex">
<span>def <span class="ident">y_start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def y_start(self):
    return self.y(self.domain.start)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="curvepy" href="index.html">curvepy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="curvepy.curve.Curve" href="#curvepy.curve.Curve">Curve</a></code></h4>
<ul class="">
<li><code><a title="curvepy.curve.Curve.abs" href="#curvepy.curve.Curve.abs">abs</a></code></li>
<li><code><a title="curvepy.curve.Curve.accumulator_map" href="#curvepy.curve.Curve.accumulator_map">accumulator_map</a></code></li>
<li><code><a title="curvepy.curve.Curve.add" href="#curvepy.curve.Curve.add">add</a></code></li>
<li><code><a title="curvepy.curve.Curve.add_many" href="#curvepy.curve.Curve.add_many">add_many</a></code></li>
<li><code><a title="curvepy.curve.Curve.add_observer" href="#curvepy.curve.Curve.add_observer">add_observer</a></code></li>
<li><code><a title="curvepy.curve.Curve.additive_inverse" href="#curvepy.curve.Curve.additive_inverse">additive_inverse</a></code></li>
<li><code><a title="curvepy.curve.Curve.begin_update" href="#curvepy.curve.Curve.begin_update">begin_update</a></code></li>
<li><code><a title="curvepy.curve.Curve.blend" href="#curvepy.curve.Curve.blend">blend</a></code></li>
<li><code><a title="curvepy.curve.Curve.centered_macs" href="#curvepy.curve.Curve.centered_macs">centered_macs</a></code></li>
<li><code><a title="curvepy.curve.Curve.const" href="#curvepy.curve.Curve.const">const</a></code></li>
<li><code><a title="curvepy.curve.Curve.count_positional_args" href="#curvepy.curve.Curve.count_positional_args">count_positional_args</a></code></li>
<li><code><a title="curvepy.curve.Curve.d_y" href="#curvepy.curve.Curve.d_y">d_y</a></code></li>
<li><code><a title="curvepy.curve.Curve.differential" href="#curvepy.curve.Curve.differential">differential</a></code></li>
<li><code><a title="curvepy.curve.Curve.divide" href="#curvepy.curve.Curve.divide">divide</a></code></li>
<li><code><a title="curvepy.curve.Curve.divide_many" href="#curvepy.curve.Curve.divide_many">divide_many</a></code></li>
<li><code><a title="curvepy.curve.Curve.domain" href="#curvepy.curve.Curve.domain">domain</a></code></li>
<li><code><a title="curvepy.curve.Curve.ema" href="#curvepy.curve.Curve.ema">ema</a></code></li>
<li><code><a title="curvepy.curve.Curve.empty" href="#curvepy.curve.Curve.empty">empty</a></code></li>
<li><code><a title="curvepy.curve.Curve.end_update" href="#curvepy.curve.Curve.end_update">end_update</a></code></li>
<li><code><a title="curvepy.curve.Curve.extension" href="#curvepy.curve.Curve.extension">extension</a></code></li>
<li><code><a title="curvepy.curve.Curve.first" href="#curvepy.curve.Curve.first">first</a></code></li>
<li><code><a title="curvepy.curve.Curve.get_domain" href="#curvepy.curve.Curve.get_domain">get_domain</a></code></li>
<li><code><a title="curvepy.curve.Curve.get_range" href="#curvepy.curve.Curve.get_range">get_range</a></code></li>
<li><code><a title="curvepy.curve.Curve.harmonic_smas" href="#curvepy.curve.Curve.harmonic_smas">harmonic_smas</a></code></li>
<li><code><a title="curvepy.curve.Curve.integral" href="#curvepy.curve.Curve.integral">integral</a></code></li>
<li><code><a title="curvepy.curve.Curve.is_updating" href="#curvepy.curve.Curve.is_updating">is_updating</a></code></li>
<li><code><a title="curvepy.curve.Curve.log" href="#curvepy.curve.Curve.log">log</a></code></li>
<li><code><a title="curvepy.curve.Curve.log_many" href="#curvepy.curve.Curve.log_many">log_many</a></code></li>
<li><code><a title="curvepy.curve.Curve.map" href="#curvepy.curve.Curve.map">map</a></code></li>
<li><code><a title="curvepy.curve.Curve.max" href="#curvepy.curve.Curve.max">max</a></code></li>
<li><code><a title="curvepy.curve.Curve.maximise" href="#curvepy.curve.Curve.maximise">maximise</a></code></li>
<li><code><a title="curvepy.curve.Curve.min" href="#curvepy.curve.Curve.min">min</a></code></li>
<li><code><a title="curvepy.curve.Curve.min_step" href="#curvepy.curve.Curve.min_step">min_step</a></code></li>
<li><code><a title="curvepy.curve.Curve.minimise" href="#curvepy.curve.Curve.minimise">minimise</a></code></li>
<li><code><a title="curvepy.curve.Curve.multiplicative_inverse" href="#curvepy.curve.Curve.multiplicative_inverse">multiplicative_inverse</a></code></li>
<li><code><a title="curvepy.curve.Curve.multiply" href="#curvepy.curve.Curve.multiply">multiply</a></code></li>
<li><code><a title="curvepy.curve.Curve.multiply_many" href="#curvepy.curve.Curve.multiply_many">multiply_many</a></code></li>
<li><code><a title="curvepy.curve.Curve.needs_domain_update" href="#curvepy.curve.Curve.needs_domain_update">needs_domain_update</a></code></li>
<li><code><a title="curvepy.curve.Curve.next_point" href="#curvepy.curve.Curve.next_point">next_point</a></code></li>
<li><code><a title="curvepy.curve.Curve.offset" href="#curvepy.curve.Curve.offset">offset</a></code></li>
<li><code><a title="curvepy.curve.Curve.parse" href="#curvepy.curve.Curve.parse">parse</a></code></li>
<li><code><a title="curvepy.curve.Curve.parse_descriptor" href="#curvepy.curve.Curve.parse_descriptor">parse_descriptor</a></code></li>
<li><code><a title="curvepy.curve.Curve.parse_many" href="#curvepy.curve.Curve.parse_many">parse_many</a></code></li>
<li><code><a title="curvepy.curve.Curve.pow" href="#curvepy.curve.Curve.pow">pow</a></code></li>
<li><code><a title="curvepy.curve.Curve.pow_many" href="#curvepy.curve.Curve.pow_many">pow_many</a></code></li>
<li><code><a title="curvepy.curve.Curve.previous_point" href="#curvepy.curve.Curve.previous_point">previous_point</a></code></li>
<li><code><a title="curvepy.curve.Curve.raised" href="#curvepy.curve.Curve.raised">raised</a></code></li>
<li><code><a title="curvepy.curve.Curve.regression" href="#curvepy.curve.Curve.regression">regression</a></code></li>
<li><code><a title="curvepy.curve.Curve.remove_observer" href="#curvepy.curve.Curve.remove_observer">remove_observer</a></code></li>
<li><code><a title="curvepy.curve.Curve.resolve_min_step" href="#curvepy.curve.Curve.resolve_min_step">resolve_min_step</a></code></li>
<li><code><a title="curvepy.curve.Curve.rsi" href="#curvepy.curve.Curve.rsi">rsi</a></code></li>
<li><code><a title="curvepy.curve.Curve.sample_points" href="#curvepy.curve.Curve.sample_points">sample_points</a></code></li>
<li><code><a title="curvepy.curve.Curve.sample_points_from_x" href="#curvepy.curve.Curve.sample_points_from_x">sample_points_from_x</a></code></li>
<li><code><a title="curvepy.curve.Curve.set_needs_interval_update" href="#curvepy.curve.Curve.set_needs_interval_update">set_needs_interval_update</a></code></li>
<li><code><a title="curvepy.curve.Curve.sma" href="#curvepy.curve.Curve.sma">sma</a></code></li>
<li><code><a title="curvepy.curve.Curve.smma" href="#curvepy.curve.Curve.smma">smma</a></code></li>
<li><code><a title="curvepy.curve.Curve.subset" href="#curvepy.curve.Curve.subset">subset</a></code></li>
<li><code><a title="curvepy.curve.Curve.subtract" href="#curvepy.curve.Curve.subtract">subtract</a></code></li>
<li><code><a title="curvepy.curve.Curve.subtract_many" href="#curvepy.curve.Curve.subtract_many">subtract_many</a></code></li>
<li><code><a title="curvepy.curve.Curve.trailing_max" href="#curvepy.curve.Curve.trailing_max">trailing_max</a></code></li>
<li><code><a title="curvepy.curve.Curve.trailing_min" href="#curvepy.curve.Curve.trailing_min">trailing_min</a></code></li>
<li><code><a title="curvepy.curve.Curve.update_interval" href="#curvepy.curve.Curve.update_interval">update_interval</a></code></li>
<li><code><a title="curvepy.curve.Curve.x" href="#curvepy.curve.Curve.x">x</a></code></li>
<li><code><a title="curvepy.curve.Curve.x_next" href="#curvepy.curve.Curve.x_next">x_next</a></code></li>
<li><code><a title="curvepy.curve.Curve.x_previous" href="#curvepy.curve.Curve.x_previous">x_previous</a></code></li>
<li><code><a title="curvepy.curve.Curve.y" href="#curvepy.curve.Curve.y">y</a></code></li>
<li><code><a title="curvepy.curve.Curve.y_end" href="#curvepy.curve.Curve.y_end">y_end</a></code></li>
<li><code><a title="curvepy.curve.Curve.y_start" href="#curvepy.curve.Curve.y_start">y_start</a></code></li>
<li><code><a title="curvepy.curve.Curve.zero" href="#curvepy.curve.Curve.zero">zero</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>